<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Jugar Tutifrutti - Completa las categor√≠as con palabras que empiecen con la letra seleccionada">
  <title>Juego - Tutifrutti</title>
  
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/base.css">
  <link rel="stylesheet" href="/public/css/components.css">
  <link rel="stylesheet" href="/public/css/game.css">
  <link rel="stylesheet" href="/public/css/game-nextgen.css">
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>
</head>
<body class="game-layout">
  <!-- Header del juego - NUEVO DISE√ëO COMPACTO -->
  <header class="game-header-compact">
    <div class="container">
      <div class="header-stats">
        <span class="app-name">üçé TUTTI FRUTTI</span>
        <span class="timer-compact">‚è±Ô∏è <span id="timerDisplay">60s</span></span>
        <span class="players-compact">üë• <span id="playersCount">0/5</span></span>
        <span class="score-compact">üíØ <span id="userScore">0</span></span>
      </div>
    </div>
  </header>
  
  <!-- Letter Display - PROMINENTE Y CENTRADA -->
  <section class="letter-section">
    <div class="container">
      <div class="current-letter-display">
        üî• <span id="letterDisplay">?</span> üî•
      </div>
      <div class="letter-label">Letra de esta ronda</div>
    </div>
  </section>

  <!-- Contenido principal -->
  <main id="main-content" class="game-main">
    <!-- Panel de estado del juego -->
    <section class="game-status">
      <div class="status-message" id="selectedLetter" aria-live="polite">
        Esperando que comience el juego...
      </div>
    </section>

    <!-- √Årea de juego -->
    <section class="game-area">
      <!-- Rejilla din√°mica de categor√≠as - GRID 4x3 RESPONSIVE -->
      <div class="categories-grid-new" id="categoriesGrid" role="group" aria-label="Categor√≠as del juego">
        <!-- Se renderiza din√°micamente con uiManager.renderCategoriesGrid -->
      </div>
    </section>

    <!-- Panel de puntuaci√≥n -->
    <section class="score-panel">
      <h2 class="score-title">
        <span aria-hidden="true">üìä</span>
        Puntuaci√≥n
      </h2>
      <div class="score-grid" role="group" aria-label="Puntuaciones actuales">
        <div class="score-item">
          <span class="score-label">Repetidas</span>
          <span class="score-value" id="score-repetidas" aria-label="Puntos por palabras repetidas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">√önicas x2</span>
          <span class="score-value" id="score-unicas" aria-label="Puntos por palabras √∫nicas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">+3 S√≠labas x3</span>
          <span class="score-value" id="score-silabas" aria-label="Puntos por palabras con m√°s de 3 s√≠labas">0</span>
        </div>
        <div class="score-item total">
          <span class="score-label">Total</span>
          <span class="score-value" id="score-total" aria-label="Puntuaci√≥n total">0</span>
        </div>
      </div>
    </section>

    <!-- Controles del juego - NUEVA BARRA FIJA -->
    <section class="game-controls-fixed">
      <div class="container">
        <div class="controls-row">
          <button id="startGameButton" 
                  class="btn btn--primary btn--lg" 
                  style="display: none;"
                  aria-describedby="start-game-help">
            <span aria-hidden="true">üéÆ</span>
            Iniciar Juego
          </button>
          <div id="start-game-help" class="sr-only">
            Solo el anfitri√≥n puede iniciar el juego
          </div>
          
          <button id="submitWordButton" 
                  class="btn btn--success btn--lg" 
                  disabled
                  aria-describedby="submit-words-help">
            <span aria-hidden="true">üöÄ</span>
            Enviar Palabras
          </button>
          <div id="submit-words-help" class="sr-only">
            Env√≠a tus palabras cuando hayas terminado o se acabe el tiempo
          </div>
          
          <button id="bastaButton" 
                  class="btn btn--accent btn--lg" 
                  style="display: none;"
                  aria-describedby="basta-help">
            <span aria-hidden="true">‚ö°</span>
            ¬°BASTA!
          </button>
          <div id="basta-help" class="sr-only">
            Termina la ronda inmediatamente cuando hayas completado todas las categor√≠as
          </div>
          
          <button id="surrenderButton" 
                  class="btn btn--ghost btn--lg" 
                  style="display: none;"
                  aria-describedby="surrender-help">
            <span aria-hidden="true">‚è≠Ô∏è</span>
            Rendirse
          </button>
          <div id="surrender-help" class="sr-only">
            Rendirse en esta ronda
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Scripts -->
  <script type="module">
    import { socketManager } from '/public/js/socket-manager.js';
    import { gameState } from '/public/js/game-state.js';
    import { uiManager } from '/public/js/ui-manager.js';
    import { storage, validateWord, showNotification } from '/utils/helpers.js';
    import { SOCKET_EVENTS, ROUTES, GAME_CONFIG } from '/utils/constants.js';

    // Referencias a elementos
    const startGameButton = document.getElementById('startGameButton');
    const submitWordButton = document.getElementById('submitWordButton');
    const bastaButton = document.getElementById('bastaButton');
    const surrenderButton = document.getElementById('surrenderButton');
    const letterDisplay = document.getElementById('letterDisplay');
    const userScoreElement = document.getElementById('userScore');

    // Exponer para acceso global
    window.gameModule = {
      submitWords: submitWordsClassic
    };

    // Inicializaci√≥n
    init();

    function init() {
      // Verificar usuario y sala
      const username = storage.getUsername();
      const urlParams = new URLSearchParams(window.location.search);
      const roomId = urlParams.get('roomId') || storage.getCurrentRoomId();

      if (!username) {
        showNotification('Debes ingresar tu nombre primero', 'error');
        window.location.href = ROUTES.HOME;
        return;
      }

      if (!roomId) {
        showNotification('No se especific√≥ una sala v√°lida', 'error');
        window.location.href = ROUTES.CREATE_ROOM;
        return;
      }

      // Configurar estado del juego
      gameState.username = username;
      gameState.roomId = roomId;

      // Actualizar UI inicial
      if (userScoreElement) {
        userScoreElement.textContent = '0';
      }

      // Inicializar componentes
      uiManager.init();
      
      // Conectar socket y configurar eventos
      socketManager.connect();
      window.socketManager = socketManager;
      setupSocketListeners();
      setupEventListeners();
      attachWordInputEvents();

      // NO unirse nuevamente - ya estamos unidos desde la sala de espera
      // En su lugar, solicitar el estado actual de la sala
      requestRoomState(roomId);

      console.log('Juego inicializado:', { username, roomId });
    }

    function requestRoomState(roomId) {
      // Verificar si venimos de la sala de espera (evitar doble uni√≥n)
      const cameFromWaitingRoom = document.referrer.includes('join-room.html') || 
                                  document.referrer.includes('create-room.html');
      
      // Siempre intentar rehidratar estado v√≠a getRoomState y reconectar internamente
      socketManager.getRoomState({ roomId });
      console.log('Solicitando estado de sala');
    }

    function setupEventListeners() {
      // Bot√≥n iniciar juego - NUEVO FLUJO: Auto-letter inmediata
      startGameButton?.addEventListener('click', () => {
        if (gameState.isHost) {
          startGameButton.disabled = true;
          startGameButton.innerHTML = '<span class="spinner"></span> Iniciando...';
          socketManager.startGame(gameState.roomId);
          showNotification('¬°Iniciando juego con letra autom√°tica!', 'info');
        } else {
          showNotification('Solo el anfitri√≥n puede iniciar el juego', 'warning');
        }
      });

      // Bot√≥n enviar palabras
      submitWordButton?.addEventListener('click', submitWordsClassic);
      
      // Bot√≥n ¬°BASTA! - Termina la ronda inmediatamente
      bastaButton?.addEventListener('click', () => {
        console.log('üî• ¬°BASTA! presionado - terminando ronda inmediatamente');
        
        // Enviar palabras y forzar fin de ronda
        submitWordsClassic();
        
        // Notificar al servidor que se termin√≥ la ronda
        socketManager.emit('forceEndRound', { 
          roomId: gameState.roomId,
          playerName: gameState.username 
        });
        
        showNotification('¬°Has terminado la ronda!', 'success');
        
        // Ocultar bot√≥n despu√©s de usar
        bastaButton.style.display = 'none';
      });
      
      // Bot√≥n rendirse
      surrenderButton?.addEventListener('click', () => {
        if (confirm('¬øEst√°s seguro de que quieres rendirte en esta ronda?')) {
          submitWordsClassic(); // Env√≠a palabras actuales
          showNotification('Te has rendido en esta ronda', 'info');
        }
      });
    }

    function attachWordInputEvents() {
      const wordInputs = document.querySelectorAll('.word-input');
      
      wordInputs.forEach((input, index) => {
        // Navegaci√≥n con Enter
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            moveToNextCategory(index);
          }
          
          // Enviar con Ctrl+Enter
          if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            submitWordsClassic();
          }
        });

        // Validaci√≥n en tiempo real con restricci√≥n de letra
        input.addEventListener('input', function() {
          const category = this.getAttribute('data-category');
          let word = this.value.trim();
          
          // NUEVA VALIDACI√ìN: Bloquear primera letra incorrecta
          if (word.length > 0 && gameState.currentLetter) {
            const firstChar = normalizeFirstLetter(word.charAt(0));
            const targetLetter = gameState.currentLetter.toUpperCase();
            
            if (firstChar !== targetLetter) {
              // Bloquear entrada - remover √∫ltimo car√°cter
              this.value = word.slice(0, -1);
              word = this.value.trim();
              
              // Feedback visual de error
              this.classList.add('blocked');
              setTimeout(() => this.classList.remove('blocked'), 200);
              
              // Mostrar mensaje de error temporal
              showTemporaryError(this, `Debe empezar con "${targetLetter}"`);
              return;
            }
          }
          
          // No validar autom√°ticamente - la validaci√≥n se hace en revisi√≥n social
          const hasContent = word && word.length > 0;
          
          // Actualizar visualizaci√≥n sin validaci√≥n autom√°tica
          updateCategoryCardState(this, category, word, hasContent);
          
          // Verificar si todas las palabras est√°n completas
          checkAllWordsCompleted();
        });

        // Gesti√≥n del foco
        input.addEventListener('focus', function() {
          uiManager.setActiveInput(this);
        });

        input.addEventListener('blur', function() {
          uiManager.removeActiveInput(this);
        });
      });
    }

    function setupSocketListeners() {
      // Conexi√≥n y errores
      socketManager.on(SOCKET_EVENTS.JOINED_ROOM, handleJoinedRoom);
      socketManager.on(SOCKET_EVENTS.PLAYER_JOINED, handlePlayerJoined);
      socketManager.on(SOCKET_EVENTS.PLAYER_LEFT, handlePlayerLeft);
      
      // Estado de la sala
      socketManager.on(SOCKET_EVENTS.ROOM_STATE, handleRoomState);
      
      // Juego - NUEVO FLUJO: Solo ROUND_START
      socketManager.on(SOCKET_EVENTS.ROUND_START, handleRoundStart);
      socketManager.on(SOCKET_EVENTS.START_REVIEW, handleStartReview);
      socketManager.on(SOCKET_EVENTS.TIMER_UPDATE, handleTimerUpdate);
      socketManager.on(SOCKET_EVENTS.ROUND_ENDED, handleRoundEnded);
      socketManager.on(SOCKET_EVENTS.GAME_ENDED, handleGameEnded);

      // Eventos futuros (validaci√≥n social)
      // Ya configurado arriba
      socketManager.on(SOCKET_EVENTS.VOTE_UPDATE, handleVoteUpdate);
      socketManager.on(SOCKET_EVENTS.REVIEW_ENDED, handleReviewEnded);

      // Eventos de host
      socketManager.on(SOCKET_EVENTS.YOU_ARE_CREATOR, () => {
        gameState.setHost(true);
        const startButton = document.getElementById('startGameButton');
        if (startButton) startButton.style.display = 'block';
      });
    }

    function handleRoomState(data) {
      console.log('Estado de la sala recibido:', data);
      
      if (!data || !data.players) {
        console.error('Estado de sala inv√°lido:', data);
        showNotification('Error al cargar el estado de la sala', 'error');
        return;
      }
      
      // Actualizar estado del juego
      gameState.updatePlayers(data.players);
      
      // Verificar si el jugador actual es el creador
      const currentPlayer = data.players.find(p => p.name === gameState.username);
      const isCreator = currentPlayer ? currentPlayer.isCreator : false;
      gameState.setHost(isCreator);
      
      console.log(`Jugador actual: ${gameState.username}, Es creador: ${isCreator}`);
      
      // NUEVO FLUJO: Sin ruleta, directo a juego si est√° en curso
      if (data.isPlaying) {
        gameState.startGame();
        if (data.currentLetter) {
          // Juego en curso con letra: renderizar categor√≠as y mostrar letra
          displayCurrentLetter(data.currentLetter);
          uiManager.renderCategoriesGrid(data.categories || GAME_CONFIG.CATEGORIES);
          attachWordInputEvents();
          gameState.setCurrentLetter(data.currentLetter);
          document.getElementById('selectedLetter').textContent = `¬°Escribiendo con la letra ${data.currentLetter}!`;
        } else {
          // Juego en curso sin letra: estado transitorio, esperar ROUND_START
          document.getElementById('selectedLetter').textContent = 'Generando letra autom√°tica...';
        }
        if (startGameButton) startGameButton.style.display = 'none';
      } else if (isCreator) {
        // Mostrar bot√≥n de iniciar juego si es el creador y el juego no ha empezado
        if (startGameButton) {
          startGameButton.style.display = 'block';
        }
        document.getElementById('selectedLetter').textContent = '¬°Haz clic en "Iniciar Juego" para comenzar!';
        uiManager.announce('Eres el anfitri√≥n. Puedes iniciar el juego cuando est√©s listo.');
      } else {
        document.getElementById('selectedLetter').textContent = 'Esperando que el anfitri√≥n inicie el juego...';
      }
      
      uiManager.announce(`Estado del juego cargado. ${data.players.length} jugadores en la sala.`);
      showNotification('¬°Listo para jugar!', 'success');
    }

    function handleJoinedRoom(data) {
      console.log('Unido a la sala:', data);
      
      gameState.updatePlayers(data.players || []);
      const isCreator = data.isCreator || false;
      gameState.setHost(isCreator);
      
      console.log(`Unido a sala - Es creador: ${isCreator}`);
      
      // Si es el creador, mostrar controles apropiados
      if (isCreator) {
        const startButton = document.getElementById('startGameButton');
        if (startButton) {
          startButton.style.display = 'block';
        }
        uiManager.announce('Eres el anfitri√≥n de esta sala.');
      }
      
      uiManager.announce(`Te has unido a la sala. Hay ${data.players?.length || 0} jugadores.`);
    }

    function handlePlayerJoined(data) {
      console.log('Jugador se uni√≥:', data);
      if (data && data.players) {
        gameState.updatePlayers(data.players);
      }
      const playerName = data?.player?.name;
      if (playerName && playerName !== gameState.username) {
        uiManager.announce(`${playerName} se uni√≥ al juego`);
        showNotification(`${playerName} se uni√≥ al juego`, 'info');
      }
    }

    function handlePlayerLeft(data) {
      console.log('Jugador se fue:', data);
      
      if (data.players) {
        gameState.updatePlayers(data.players);
        
        if (data.playerName && data.playerName !== gameState.username) {
          uiManager.announce(`${data.playerName} dej√≥ el juego`);
          showNotification(`${data.playerName} dej√≥ el juego`, 'info');
        }
      }
    }

    // NUEVA FUNCI√ìN: Mostrar letra en header compacto
    function displayCurrentLetter(letter) {
      if (letterDisplay) {
        letterDisplay.textContent = letter;
      }
      // Tambi√©n actualizar en el panel de estado
      const statusMessage = document.getElementById('selectedLetter');
      if (statusMessage) {
        statusMessage.textContent = `¬°Escribiendo con la letra ${letter}!`;
      }
      uiManager.announce(`Letra seleccionada: ${letter}. ¬°A escribir!`);
    }

    // FUNCI√ìN: Normalizar primera letra (tildes + √ë)
    function normalizeFirstLetter(char) {
      const normalized = char.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      return normalized.toUpperCase();
    }

    // FUNCI√ìN: Mostrar error temporal en input
    function showTemporaryError(input, message) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Crear elemento de error temporal
      const errorEl = document.createElement('div');
      errorEl.className = 'temp-error';
      errorEl.textContent = message;
      errorEl.style.cssText = `
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--color-error);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        animation: errorPulse 2s ease-out forwards;
      `;
      
      card.style.position = 'relative';
      card.appendChild(errorEl);
      
      setTimeout(() => {
        if (errorEl.parentNode) {
          errorEl.parentNode.removeChild(errorEl);
        }
      }, 2000);
    }

    // FUNCI√ìN: Actualizar estado visual de categoria card (SIN validaci√≥n autom√°tica)
    function updateCategoryCardState(input, category, word, hasContent) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Limpiar clases previas
      card.classList.remove('completed', 'invalid', 'empty', 'filled');
      input.classList.remove('valid', 'invalid', 'filled');
      
      if (hasContent) {
        // Solo marcar como "filled" sin validar
        card.classList.add('filled');
        input.classList.add('filled');
      } else {
        card.classList.add('empty');
      }
      
      // Actualizar feedback visual sin validaci√≥n
      updateCategoryFeedback(card, word, hasContent);
    }

    // FUNCI√ìN: Feedback visual en categoria card (SIN validaci√≥n autom√°tica)
    function updateCategoryFeedback(card, word, hasContent) {
      let feedbackEl = card.querySelector('.category-card__feedback');
      
      if (hasContent) {
        if (!feedbackEl) {
          feedbackEl = document.createElement('div');
          feedbackEl.className = 'category-card__feedback';
          card.appendChild(feedbackEl);
        }
        
        // Solo mostrar que tiene contenido, sin validar
        feedbackEl.className = 'category-card__feedback filled';
        feedbackEl.textContent = 'üìù';
        feedbackEl.setAttribute('aria-label', 'Palabra ingresada');
      } else if (feedbackEl) {
        feedbackEl.remove();
      }
    }

    // NUEVO FLUJO: Round start con auto-letter inmediata
    function handleRoundStart(data) {
      try {
        console.log('[Game] handleRoundStart - NUEVO FLUJO:', data);
        
        const categories = data?.categories || GAME_CONFIG.CATEGORIES;
        
        // Ocultar bot√≥n de iniciar juego
        if (startGameButton) startGameButton.style.display = 'none';
        
        // Mostrar letra en header compacto
        displayCurrentLetter(data.letter);
        
        // Render de categor√≠as din√°micas en grid 4x3
        uiManager.renderCategoriesGrid(categories);
        attachWordInputEvents();
        
        // Configurar estado del juego
        gameState.setCurrentLetter(data.letter);
        gameState.enableInputs();
        gameState.startGame();

        // Mostrar bot√≥n de rendirse durante el juego
        if (surrenderButton) {
          surrenderButton.style.display = 'inline-block';
        }

        // Enfocar primer input disponible para UX
        setTimeout(() => {
          const first = document.querySelector('.word-input:not([disabled])');
          if (first) { 
            try { first.focus(); } catch(_) {} 
          }
        }, 100);

        // FASE 4: Manejar Letter Streak System si existe
        if (data.streakBonuses && Object.keys(data.streakBonuses).length > 0) {
          handleLetterStreakBonus(data);
        }
        
        if (data.isRare || data.isMedium) {
          highlightSpecialLetter(data.letter, data.isRare ? 'rare' : 'medium');
        }
        
        showNotification(`¬°Ronda ${data.round} iniciada con letra ${data.letter}!`, 'success');
        uiManager.announce(`Ronda ${data.round} iniciada con letra ${data.letter}. ¬°Tiempo para escribir!`);
      } catch (e) {
        console.error('Error en handleRoundStart:', e);
        showNotification('Error al iniciar la ronda', 'error');
      }
    }

    function handleStartReview(data) {
      try {
        console.log('üîÑ [GAME.HTML] Iniciando revisi√≥n social:', data);
        console.log('üîÑ [GAME.HTML] Estado actual del juego:', {
          roomId: gameState.roomId,
          isPlaying: gameState.isPlaying,
          timeRemaining: gameState.timeRemaining
        });
        
        // Bloquear entradas y bot√≥n de enviar
        gameState.disableInputs();
        if (submitWordButton) submitWordButton.disabled = true;
        
        // Mostrar notificaci√≥n de transici√≥n
        showNotification(data.message || '¬°Hora de revisar las palabras!', 'info');
        
        // SOLUCI√ìN DEFINITIVA: Implementar revisi√≥n 100% NATIVA
        try {
          console.log('üîÑ [GAME.HTML] Implementando revisi√≥n NATIVA - SIN redirecci√≥n...');
          
          // Ocultar interfaz de juego
          const gameContainer = document.querySelector('.game-container');
          if (gameContainer) {
            gameContainer.style.display = 'none';
          }
          
          // Implementar interfaz de revisi√≥n directamente
          implementNativeReviewInterface(data);
          
        } catch (error) {
          console.error('‚ùå [GAME.HTML] Error implementando revisi√≥n nativa:', error);
          showNotification('Error al implementar revisi√≥n', 'error');
        }
        
      } catch (e) {
        console.error('Error en handleStartReview:', e);
        showNotification('Error al iniciar la revisi√≥n', 'error');
      }
    }

    // Funci√≥n handleVoteUpdate removida - duplicada, se usa la versi√≥n m√°s completa en l√≠nea 1195

    function handleReviewEnded(data) {
      try {
        // Cerrar modal de revisi√≥n; los resultados llegar√°n por ROUND_ENDED
        uiManager.closeReviewModal();
      } catch (e) {
        console.error('Error en handleReviewEnded:', e);
      }
    }

    function handleTimerUpdate(data) {
      gameState.timeRemaining = data.timeRemaining;
      gameState.updateTimerDisplay();
      
      // Advertencia cuando queden pocos segundos
      if (data.timeRemaining <= 10 && data.timeRemaining > 0) {
        if (data.timeRemaining <= 5) {
          uiManager.announce(`¬°${data.timeRemaining} segundos!`);
        }
      }
      if (data.timeRemaining <= 0) {
        // Evitar acciones locales; el servidor cerrar√° la ronda
        gameState.clearTimer();
      }
    }

    function handleRoundEnded(data) {
      console.log('[Game] handleRoundEnded ->', data);
      
      gameState.clearTimer();
      gameState.disableInputs();
      gameState.updatePlayerScore(data.scores);
      
      // Mostrar resultados
      uiManager.showRoundResults(data);
      
      // Limpiar campos para la siguiente ronda
      clearWordInputs();
      
      uiManager.announce('La ronda ha terminado. Revisa los resultados.');
      
      // Preparar para la siguiente ronda: esperar ROUND_START del servidor
      const selectedLetterEl = document.getElementById('selectedLetter');
      if (selectedLetterEl) {
        selectedLetterEl.textContent = 'Esperando siguiente ronda...';
      }
    }

    function handleGameEnded(data) {
      console.log('Juego terminado:', data);
      
      gameState.clearTimer();
      gameState.gameStarted = false;
      
      // Mostrar resultados finales
      showGameResults(data.results);
      
      uiManager.announce('El juego ha terminado. Revisa los resultados finales.');
    }

    function moveToNextCategory(currentIndex) {
      const wordInputs = document.querySelectorAll('.word-input');
      const nextIndex = (currentIndex + 1) % wordInputs.length;
      
      if (nextIndex < wordInputs.length && !wordInputs[nextIndex].disabled) {
        wordInputs[nextIndex].focus();
      }
    }
    
    // SOLUCI√ìN DEFINITIVA: Implementar revisi√≥n 100% NATIVA
    function implementNativeReviewInterface(data) {
      try {
        console.log('üîÑ [GAME.HTML] Creando interfaz de revisi√≥n NATIVA...');
        
        // Crear contenedor de revisi√≥n manteniendo la ESENCIA del proyecto
        const reviewContainer = document.createElement('div');
        reviewContainer.id = 'native-review-container';
        reviewContainer.innerHTML = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          ">
            <!-- Header del juego manteniendo nuestro estilo -->
            <div style="
              text-align: center;
              color: white;
              margin-bottom: 30px;
            ">
              <h2 style="font-size: 32px; margin: 0 0 10px 0; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                üîç Revisi√≥n Social de Palabras
              </h2>
              <div style="
                display: flex;
                justify-content: center;
                gap: 30px;
                font-size: 18px;
                font-weight: 600;
                text-shadow: 0 1px 2px rgba(0,0,0,0.3);
              ">
                <span>Ronda: <strong>${data.round || 1}</strong></span>
                <span>Letra: <strong>${data.letter || 'X'}</strong></span>
              </div>
            </div>
            
            <!-- Panel de instrucciones con nuestro estilo -->
            <div style="
              background: rgba(255, 255, 255, 0.95);
              border-radius: 12px;
              padding: 20px;
              margin: 0 auto 25px;
              max-width: 700px;
              color: #333;
              font-size: 16px;
              text-align: center;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
              border: 2px solid rgba(255,255,255,0.3);
            ">
              <strong>üìä Sistema de Votaci√≥n Social:</strong><br>
              Vota si cada palabra es v√°lida (‚úì) o inv√°lida (‚úó). Los resultados se decidir√°n por consenso.
            </div>
            
            <!-- Panel principal manteniendo nuestro estilo -->
            <div style="
              background: rgba(255, 255, 255, 0.98);
              border-radius: 15px;
              padding: 30px;
              margin: 0 auto;
              max-width: 1000px;
              box-shadow: 0 8px 25px rgba(0,0,0,0.2);
              border: 2px solid rgba(255,255,255,0.3);
            ">
              <div id="review-status" style="
                text-align: center;
                color: #666;
                margin-bottom: 25px;
                font-size: 16px;
              ">Esperando datos de revisi√≥n...</div>
              
              <!-- Contenedor de votaci√≥n -->
              <div id="players-voting-container">
                <!-- Se llenar√° din√°micamente -->
              </div>
              
              <!-- Bot√≥n de confirmaci√≥n con nuestro estilo -->
              <div style="text-align: center; margin-top: 30px;">
                <button id="confirm-votes-btn" style="
                  background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                  color: white;
                  border: none;
                  padding: 15px 40px;
                  border-radius: 25px;
                  font-size: 18px;
                  font-weight: 600;
                  cursor: pointer;
                  box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                  transition: all 0.3s ease;
                  text-transform: uppercase;
                  letter-spacing: 1px;
                " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(76, 175, 80, 0.5)'"
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.4)'">
                  ‚úÖ Confirmar Votaci√≥n
                </button>
              </div>
            </div>
            
            <!-- Controles de emergencia -->
            <div style="
              position: fixed;
              bottom: 20px;
              right: 20px;
              background: rgba(255, 255, 255, 0.9);
              padding: 12px;
              border-radius: 12px;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            ">
              <button id="skip-review-btn" style="
                background: #FF9800;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s ease;
              " onmouseover="this.style.background='#F57C00'"
                 onmouseout="this.style.background='#FF9800'">
                ‚è≠Ô∏è Saltar
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(reviewContainer);
        
        // Configurar handlers de la revisi√≥n nativa
        setupNativeReviewHandlers(data);
        
        // Solicitar datos de revisi√≥n al servidor
        socketManager.emit('getRoomState', { roomId: gameState.roomId });
        
        console.log('‚úÖ [GAME.HTML] Interfaz de revisi√≥n NATIVA implementada');
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error en implementNativeReviewInterface:', error);
        showNotification('Error al implementar revisi√≥n nativa', 'error');
      }
    }
    
    // Configurar handlers para la revisi√≥n nativa
    function setupNativeReviewHandlers(data) {
      try {
        // Handler para confirmar votaci√≥n
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          confirmBtn.addEventListener('click', () => {
            console.log('üîÑ [GAME.HTML] Usuario confirm√≥ votaci√≥n...');
            
            // Prevenir m√∫ltiples env√≠os
            if (votingState.resultsSent) {
              console.warn('üö´ [GAME.HTML] Resultados ya enviados, ignorando click');
              return;
            }
            
            confirmVotingResults();
          });
        }
        
        // Handler para saltar revisi√≥n (emergencia)
        const skipBtn = document.getElementById('skip-review-btn');
        if (skipBtn) {
          skipBtn.addEventListener('click', () => {
            console.log('üîÑ [GAME.HTML] Usuario eligi√≥ saltar revisi√≥n...');
            showNotification('Saltando revisi√≥n...', 'info');
            finishNativeReview();
          });
        }
        
        // Escuchar eventos de revisi√≥n del servidor
        socketManager.on('reviewData', handleNativeReviewData);
        socketManager.on('reviewEnded', handleNativeReviewEnded);
        socketManager.on('roomState', handleNativeRoomState);
        socketManager.on('voteUpdate', handleVoteUpdate);
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error configurando handlers:', error);
      }
    }
    
    // Handler para datos de revisi√≥n - Sistema de votaci√≥n con esencia del proyecto
    function handleNativeReviewData(data) {
      try {
        console.log('üìä [GAME.HTML] Datos de revisi√≥n recibidos:', data);
        
        const statusDiv = document.getElementById('review-status');
        if (statusDiv) {
          statusDiv.innerHTML = `
            <div style="color: #4CAF50; font-weight: 600; margin-bottom: 10px;">
              ‚úÖ ¬°Datos de revisi√≥n cargados correctamente!
            </div>
            <div>
              ${data.players?.length || 0} jugadores ‚Ä¢ ${data.players?.[0]?.words?.length || 0} categor√≠as ‚Ä¢ Letra <strong>${data.letter}</strong>
            </div>
          `;
        }
        
        // Contenedor principal de votaci√≥n
        const votingContainer = document.getElementById('players-voting-container');
        if (!votingContainer || !data.players) return;
        
        votingContainer.innerHTML = '';
        
        // Crear grid de palabras organizado por categor√≠as (manteniendo nuestro estilo)
        const categories = [...new Set(data.players.flatMap(p => p.words?.map(w => w.category) || []))];
        
        categories.forEach((category, categoryIndex) => {
          const categorySection = document.createElement('div');
          categorySection.style.cssText = `
            margin-bottom: 35px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
          `;
          
          // T√≠tulo de categor√≠a con nuestro estilo
          categorySection.innerHTML = `
            <div style="
              text-align: center;
              margin-bottom: 20px;
              padding: 15px;
              background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
              border-radius: 10px;
              border: 1px solid rgba(102, 126, 234, 0.3);
            ">
              <h3 style="
                font-size: 22px;
                font-weight: 700;
                color: #333;
                margin: 0;
                text-transform: uppercase;
                letter-spacing: 1px;
              ">
                üìù ${category}
              </h3>
              <div style="font-size: 14px; color: #666; margin-top: 5px;">
                Letra: <strong style="color: #667eea;">${data.letter}</strong>
              </div>
            </div>
          `;
          
          // Grid de jugadores para esta categor√≠a
          const playersGrid = document.createElement('div');
          playersGrid.style.cssText = `
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
          `;
          
          data.players.forEach((player, playerIndex) => {
            const word = player.words?.find(w => w.category === category);
            if (!word) return;
            
            // L√ìGICA JUSTA: Verificar si el usuario actual es el autor de esta palabra
            const isOwnWord = player.name === votingState.currentUser;
            console.log(`üîç [GAME.HTML] Verificando palabra: ${player.name} vs ${votingState.currentUser} = ${isOwnWord}`);
            
            const playerVoteCard = document.createElement('div');
            playerVoteCard.style.cssText = `
              background: ${isOwnWord ? 'linear-gradient(135deg, #fff3e0, #ffe0b2)' : 'white'};
              border: 2px solid ${isOwnWord ? '#ff9800' : '#e0e0e0'};
              border-radius: 15px;
              padding: 20px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
              ${isOwnWord ? 'opacity: 0.8;' : ''}
            `;
            
            // Avatares simples pero consistentes con nuestro estilo
            const playerColors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#fa709a', '#fee140'];
            const playerColor = playerColors[playerIndex % playerColors.length];
            const playerInitial = player.name.charAt(0).toUpperCase();
            
            playerVoteCard.innerHTML = `
              <!-- Header del jugador -->
              <div style="
                display: flex;
                align-items: center;
                gap: 15px;
                margin-bottom: 15px;
                padding-bottom: 15px;
                border-bottom: 2px solid #f0f0f0;
              ">
                <div style="
                  width: 45px;
                  height: 45px;
                  background: linear-gradient(135deg, ${playerColor}, ${playerColor}cc);
                  border-radius: 50%;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 20px;
                  font-weight: bold;
                  color: white;
                  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                ">
                  ${playerInitial}
                </div>
                <div>
                  <div style="font-weight: 700; color: #333; font-size: 18px;">
                    ${player.name} ${isOwnWord ? '(T√∫)' : ''}
                  </div>
                  <div style="font-size: 12px; color: ${isOwnWord ? '#ff9800' : '#888'}; text-transform: uppercase; letter-spacing: 0.5px;">
                    ${isOwnWord ? 'üö´ No puedes votar tu propia palabra' : `Jugador ${playerIndex + 1}`}
                  </div>
                </div>
              </div>
              
              <!-- Palabra con nuestro estilo -->
              <div style="
                background: linear-gradient(135deg, #f8f9ff, #f0f4ff);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                border: 2px solid #e8edff;
                text-align: center;
              ">
                <div style="
                  font-size: 24px;
                  font-weight: 700;
                  color: #333;
                  min-height: 30px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                ">
                  ${word.word || '(sin respuesta)'}
                </div>
              </div>
              
              <!-- Sistema de votaci√≥n adaptado - L√ìGICA JUSTA -->
              <div style="
                display: flex;
                gap: 15px;
                justify-content: center;
                align-items: center;
              ">
                ${isOwnWord ? `
                  <!-- Palabras propias: Solo mostrar indicadores, no botones -->
                  <div style="
                    background: linear-gradient(135deg, #FFF3E0, #FFE0B2);
                    border: 2px solid #FF9800;
                    border-radius: 15px;
                    padding: 20px;
                    text-align: center;
                    min-width: 200px;
                    color: #E65100;
                    font-weight: 600;
                  ">
                    <div style="font-size: 16px; margin-bottom: 8px;">üîí Tu palabra</div>
                    <div style="font-size: 14px;">Esperando votos de otros jugadores</div>
                    <div id="vote-count-${player.name}-${category}" style="font-size: 12px; margin-top: 8px; color: #666;">
                      0/0 votos recibidos
                    </div>
                  </div>
                ` : `
                  <!-- Palabras de otros: Botones de votaci√≥n normales -->
                  <button 
                    id="vote-valid-${player.name}-${category}"
                    onclick="castVoteForWord('${player.name}', '${category}', true)"
                    style="
                      background: linear-gradient(135deg, #4CAF50, #45a049);
                      color: white;
                      border: none;
                      width: 55px;
                      height: 55px;
                      border-radius: 15px;
                      font-size: 24px;
                      cursor: pointer;
                      transition: all 0.3s ease;
                      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                      font-weight: bold;
                    "
                    onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(76, 175, 80, 0.5)'"
                    onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.4)'"
                  >
                    ‚úì
                  </button>
                  
                  <!-- Indicador de votos con nuestro estilo -->
                  <div id="vote-indicator-${player.name}-${category}" style="
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                    min-width: 70px;
                    align-items: center;
                    font-size: 14px;
                    color: #666;
                  ">
                    <div style="font-weight: 600;">Votos</div>
                    <div id="vote-count-${player.name}-${category}">0/0</div>
                  </div>
                  
                  <!-- Bot√≥n INV√ÅLIDA -->
                  <button 
                    id="vote-invalid-${player.name}-${category}"
                    onclick="castVoteForWord('${player.name}', '${category}', false)"
                    style="
                      background: linear-gradient(135deg, #f44336, #d32f2f);
                      color: white;
                      border: none;
                      width: 55px;
                      height: 55px;
                      border-radius: 15px;
                      font-size: 24px;
                      cursor: pointer;
                      transition: all 0.3s ease;
                      box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
                      font-weight: bold;
                    "
                    onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(244, 67, 54, 0.5)'"
                    onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(244, 67, 54, 0.4)'"
                  >
                    ‚úó
                  </button>
                `}
              </div>
            `;
            
            playersGrid.appendChild(playerVoteCard);
          });
          
          categorySection.appendChild(playersGrid);
          votingContainer.appendChild(categorySection);
        });
        
        // Inicializar estado de votaci√≥n
        initializeVotingState(data);
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error procesando datos de revisi√≥n:', error);
      }
    }
    
    // Handler para estado de sala (fallback)
    function handleNativeRoomState(data) {
      try {
        console.log('üè† [GAME.HTML] Estado de sala recibido:', data);
        
        // Si estamos en revisi√≥n pero no recibimos reviewData, mostrar info b√°sica
        const statusDiv = document.getElementById('review-status');
        if (statusDiv) {
          statusDiv.innerHTML = `
            <span style="color: #FF9800;">‚è≥ Preparando revisi√≥n...</span><br>
            Sala: ${data.roomId} | Jugadores: ${data.players?.length || 0}
          `;
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error procesando estado de sala:', error);
      }
    }
    
    // Finalizar revisi√≥n nativa
    function finishNativeReview() {
      try {
        console.log('üîÑ [GAME.HTML] Finalizando revisi√≥n nativa...');
        
        // Remover interfaz de revisi√≥n
        const reviewContainer = document.getElementById('native-review-container');
        if (reviewContainer) {
          reviewContainer.remove();
        }
        
        // Mostrar interfaz de juego nuevamente
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
          gameContainer.style.display = 'block';
        }
        
        // Limpiar estado de votaci√≥n para evitar conflictos
        votingState = {
          votes: {},
          currentUser: null,
          currentLetter: null,
          isVoting: false,
          resultsSent: false
        };
        
        // NO mostrar notificaci√≥n aqu√≠ para evitar espameo
        // showNotification('Revisi√≥n completada', 'success');
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error finalizando revisi√≥n:', error);
      }
    }
    
    // Handler para cuando la revisi√≥n termina
    function handleNativeReviewEnded(data) {
      try {
        console.log('‚úÖ [GAME.HTML] Revisi√≥n terminada:', data);
        finishNativeReview();
        
        if (data.nextRound) {
          showNotification(`¬°Pr√≥xima ronda! Letra: ${data.nextRound.letter}`, 'info');
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error manejando fin de revisi√≥n:', error);
      }
    }
    
    // Handler para actualizaciones de votos en tiempo real
    function handleVoteUpdate(data) {
      try {
        console.log('üîÑ [GAME.HTML] Actualizaci√≥n de voto recibida:', data);
        
        const { wordId, playerName, category, validCount, invalidCount, voter, isValid } = data;
        
        if (!wordId || !playerName || !category) return;
        
        // Actualizar estado local de votaci√≥n
        const key = `${playerName}-${category}`;
        if (votingState.votes[key]) {
          // Solo actualizar si el voto no es nuestro (evitar doble actualizaci√≥n)
          if (voter !== votingState.currentUser) {
            votingState.votes[key].valid = validCount || 0;
            votingState.votes[key].invalid = invalidCount || 0;
          }
          
          // Actualizar UI para esta palabra
          updateVoteUIFromServer(playerName, category, validCount, invalidCount);
        }
        
        // Mostrar notificaci√≥n sutil de voto recibido
        if (voter !== votingState.currentUser) {
          const voteText = isValid ? 'v√°lida' : 'inv√°lida';
          showNotification(`${voter} vot√≥ ${voteText} para ${playerName}`, 'info', 2000);
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error procesando actualizaci√≥n de voto:', error);
      }
    }
    
    // Actualizar UI desde datos del servidor
    function updateVoteUIFromServer(playerName, category, validCount, invalidCount) {
      try {
        const indicator = document.getElementById(`vote-count-${playerName}-${category}`);
        if (indicator) {
          const totalVotes = (validCount || 0) + (invalidCount || 0);
          const isOwnWord = playerName === votingState.currentUser;
          
          if (isOwnWord) {
            // Para palabras propias, mostrar votos recibidos
            indicator.innerHTML = `
              <div style="font-weight: 600; color: ${validCount > invalidCount ? '#4CAF50' : invalidCount > validCount ? '#f44336' : '#666'};">
                ${totalVotes}/${votingState.totalPlayers - 1} votos
              </div>
              <div style="font-size: 12px;">
                ‚úì${validCount || 0} ‚úó${invalidCount || 0}
              </div>
            `;
          } else {
            // Para palabras de otros, mostrar progreso
            indicator.innerHTML = `
              <div style="font-weight: 600; color: ${validCount > invalidCount ? '#4CAF50' : invalidCount > validCount ? '#f44336' : '#666'};">
                ${totalVotes}/${votingState.totalPlayers}
              </div>
              <div style="font-size: 12px;">
                ‚úì${validCount || 0} ‚úó${invalidCount || 0}
              </div>
            `;
          }
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error actualizando UI desde servidor:', error);
      }
    }
    
    // SISTEMA DE VOTACI√ìN - Estado y funciones
    let votingState = {
      votes: {}, // { "playerName-category": { valid: 0, invalid: 0, userVote: null } }
      totalPlayers: 0,
      currentUser: null
    };
    
    // Inicializar estado de votaci√≥n
    function initializeVotingState(data) {
      try {
        console.log('üîß [GAME.HTML] Inicializando estado de votaci√≥n...');
        
        votingState.totalPlayers = data.players?.length || 0;
        
        // Obtener nombre del usuario actual de m√∫ltiples fuentes
        votingState.currentUser = gameState.playerName || 
                                 localStorage.getItem('playerName') || 
                                 document.querySelector('[data-player-name]')?.dataset.playerName ||
                                 'Usuario';
        
        console.log(`üë§ [GAME.HTML] Usuario actual identificado: ${votingState.currentUser}`);
        votingState.votes = {};
        
        // Inicializar votos para cada palabra - CON MEJORAS
        data.players?.forEach(player => {
          player.words?.forEach(word => {
            const key = `${player.name}-${word.category}`;
            votingState.votes[key] = {
              valid: 0,
              invalid: 0,
              userVote: null,
              word: word.word,
              player: player.name,
              category: word.category,
              isOwnWord: player.name === votingState.currentUser, // Flag para palabras propias
              isEmpty: !word.word || word.word.trim() === '', // Flag para palabras vac√≠as
              createdAt: Date.now() // Timestamp para ordenamiento
            };
          });
        });
        
        // Guardar letra actual para progreso
        votingState.currentLetter = data.letter;
        
        console.log('‚úÖ [GAME.HTML] Estado de votaci√≥n inicializado:', votingState);
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error inicializando votaci√≥n:', error);
      }
    }
    
    // Funci√≥n global para votar (llamada desde onclick) - CON L√ìGICA JUSTA
    window.castVoteForWord = function(playerName, category, isValid) {
      try {
        console.log(`üó≥Ô∏è [GAME.HTML] Intento de voto: ${playerName}-${category} = ${isValid ? 'V√ÅLIDA' : 'INV√ÅLIDA'}`);
        console.log(`üîç [GAME.HTML] Usuario actual: ${votingState.currentUser}, Jugador objetivo: ${playerName}`);
        
        // VERIFICACI√ìN CR√çTICA: No permitir votar por palabras propias
        // Verificar m√∫ltiples fuentes para el nombre del usuario actual
        const currentUserNames = [
          votingState.currentUser,
          gameState.playerName,
          localStorage.getItem('playerName'),
          document.querySelector('[data-player-name]')?.dataset.playerName
        ].filter(Boolean);
        
        const isOwnWord = currentUserNames.includes(playerName);
        
        if (isOwnWord) {
          console.warn('üö´ [GAME.HTML] Intento de voto por palabra propia bloqueado');
          showNotification('No puedes votar por tu propia palabra', 'warning');
          return;
        }
        
        const key = `${playerName}-${category}`;
        const voteData = votingState.votes[key];
        
        if (!voteData) {
          console.error('‚ùå [GAME.HTML] No se encontr√≥ la palabra para votar');
          return;
        }
        
        // Remover voto anterior si existe
        if (voteData.userVote !== null) {
          if (voteData.userVote) {
            voteData.valid = Math.max(0, voteData.valid - 1);
          } else {
            voteData.invalid = Math.max(0, voteData.invalid - 1);
          }
        }
        
        // Agregar nuevo voto
        voteData.userVote = isValid;
        if (isValid) {
          voteData.valid++;
        } else {
          voteData.invalid++;
        }
        
        console.log(`‚úÖ [GAME.HTML] Voto registrado: ${playerName}-${category} = ${isValid ? 'V√ÅLIDA' : 'INV√ÅLIDA'}`);
        
        // Actualizar UI
        updateVoteUI(playerName, category);
        
        // Enviar voto al servidor usando handler personalizado
        socketManager.emit('castVoteCustom', {
          roomId: gameState.roomId,
          playerName: playerName,
          category: category,
          isValid: isValid,
          voter: votingState.currentUser
        });
        
        // Verificar si todos han votado
        checkVotingProgress();
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error al votar:', error);
        showNotification('Error al procesar voto', 'error');
      }
    };
    
    // Actualizar UI de votaci√≥n
    function updateVoteUI(playerName, category) {
      try {
        const key = `${playerName}-${category}`;
        const voteData = votingState.votes[key];
        
        if (!voteData) return;
        
        // Actualizar botones
        const validBtn = document.getElementById(`vote-valid-${playerName}-${category}`);
        const invalidBtn = document.getElementById(`vote-invalid-${playerName}-${category}`);
        const indicator = document.getElementById(`vote-count-${playerName}-${category}`);
        
        if (validBtn && invalidBtn) {
          // Resetear estilos
          validBtn.style.opacity = voteData.userVote === true ? '1' : '0.7';
          invalidBtn.style.opacity = voteData.userVote === false ? '1' : '0.7';
          
          // Agregar indicador visual de voto del usuario
          if (voteData.userVote === true) {
            validBtn.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
            validBtn.style.border = '3px solid #ffffff';
          } else {
            validBtn.style.boxShadow = '0 4px 15px rgba(76, 175, 80, 0.4)';
            validBtn.style.border = 'none';
          }
          
          if (voteData.userVote === false) {
            invalidBtn.style.boxShadow = '0 0 20px rgba(244, 67, 54, 0.8)';
            invalidBtn.style.border = '3px solid #ffffff';
          } else {
            invalidBtn.style.boxShadow = '0 4px 15px rgba(244, 67, 54, 0.4)';
            invalidBtn.style.border = 'none';
          }
        }
        
        // Actualizar contador
        if (indicator) {
          const totalVotes = voteData.valid + voteData.invalid;
          indicator.innerHTML = `
            <div style="font-weight: 600; color: ${voteData.valid > voteData.invalid ? '#4CAF50' : voteData.invalid > voteData.valid ? '#f44336' : '#666'};">
              ${totalVotes}/${votingState.totalPlayers}
            </div>
            <div style="font-size: 12px;">
              ‚úì${voteData.valid} ‚úó${voteData.invalid}
            </div>
          `;
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error actualizando UI de voto:', error);
      }
    }
    
    // Verificar progreso de votaci√≥n - L√ìGICA JUSTA
    function checkVotingProgress() {
      try {
        // Contar solo palabras de OTROS jugadores (no las propias)
        const otherPlayersWords = Object.values(votingState.votes).filter(v => v.player !== votingState.currentUser);
        const totalVotableWords = otherPlayersWords.length;
        const votedWords = otherPlayersWords.filter(v => v.userVote !== null).length;
        
        console.log(`üìä [GAME.HTML] Progreso de votaci√≥n JUSTO: ${votedWords}/${totalVotableWords} palabras votadas (excluyendo propias)`);
        
        // Actualizar bot√≥n de confirmaci√≥n
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          if (totalVotableWords === 0) {
            // Solo hay palabras propias (caso especial: 1 jugador)
            confirmBtn.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
            confirmBtn.innerHTML = '‚è∏Ô∏è No hay palabras para votar';
            confirmBtn.disabled = true;
          } else if (votedWords === totalVotableWords) {
            confirmBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
            confirmBtn.innerHTML = '‚úÖ Confirmar Votaci√≥n Completa';
            confirmBtn.disabled = false;
          } else {
            confirmBtn.style.background = 'linear-gradient(135deg, #FF9800, #F57C00)';
            confirmBtn.innerHTML = `‚è≥ Votar Restantes (${votedWords}/${totalVotableWords})`;
            confirmBtn.disabled = false; // Permitir confirmaci√≥n parcial
          }
        }
        
        // Actualizar estad√≠sticas en el header
        const statusDiv = document.getElementById('review-status');
        if (statusDiv && totalVotableWords > 0) {
          const progressPercentage = Math.round((votedWords / totalVotableWords) * 100);
          statusDiv.innerHTML = `
            <div style="color: #4CAF50; font-weight: 600; margin-bottom: 10px;">
              ‚úÖ ¬°Datos de revisi√≥n cargados correctamente!
            </div>
            <div style="margin-bottom: 10px;">
              ${votingState.totalPlayers} jugadores ‚Ä¢ ${Object.keys(votingState.votes).length} palabras totales ‚Ä¢ Letra <strong>${votingState.currentLetter || 'X'}</strong>
            </div>
            <div style="
              background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.2));
              border-radius: 20px;
              padding: 10px;
              border: 1px solid rgba(76, 175, 80, 0.3);
              color: #2E7D32;
              font-weight: 600;
            ">
              üìä Progreso: ${votedWords}/${totalVotableWords} votos (${progressPercentage}%)
            </div>
          `;
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error verificando progreso:', error);
      }
    }
    
    // Confirmar resultados de votaci√≥n
    function confirmVotingResults() {
      try {
        console.log('‚úÖ [GAME.HTML] Confirmando resultados de votaci√≥n...');
        
        // Recopilar todos los votos
        const votingResults = {};
        Object.values(votingState.votes).forEach(vote => {
          const key = `${vote.player}-${vote.category}`;
          votingResults[key] = {
            player: vote.player,
            category: vote.category,
            word: vote.word,
            validVotes: vote.valid,
            invalidVotes: vote.invalid,
            isValid: vote.valid > vote.invalid, // Decisi√≥n por mayor√≠a
            userVoted: vote.userVote !== null
          };
        });
        
        console.log('üìä [GAME.HTML] Resultados compilados:', votingResults);
        
        // Enviar resultados al servidor (solo una vez)
        socketManager.emit('finishReview', {
          roomId: gameState.roomId,
          votingResults: votingResults,
          voter: votingState.currentUser
        });
        
        // Marcar que ya se envi√≥ para evitar duplicados
        votingState.resultsSent = true;
        
        // Mostrar feedback visual
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          confirmBtn.innerHTML = '‚è≥ Enviando resultados...';
          confirmBtn.disabled = true;
          confirmBtn.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
        }
        
        showNotification('Votaci√≥n enviada. Esperando a otros jugadores...', 'info');
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error confirmando votaci√≥n:', error);
        showNotification('Error al enviar votaci√≥n', 'error');
      }
    }

    // SISTEMA DE NAVEGACI√ìN M√ìVIL POR TABS - FASE 4
    function initializeMobileTabs() {
      try {
        const isMobile = window.innerWidth <= 480;
        const isTouch = 'ontouchstart' in window;
        const shouldUseMobile = isMobile && isTouch;
        
        if (!shouldUseMobile) {
          console.log('üì± [GAME.HTML] No es dispositivo m√≥vil, manteniendo grid desktop');
          return;
        }
        
        console.log('üì± [GAME.HTML] Inicializando navegaci√≥n m√≥vil por tabs...');
        
        const categoriesGrid = document.querySelector('.categories-grid-new');
        if (!categoriesGrid) return;
        
        // Verificar si ya est√° inicializado
        if (categoriesGrid.style.display === 'none' || document.querySelector('.mobile-game-container')) {
          console.log('üì± [GAME.HTML] Navegaci√≥n m√≥vil ya inicializada');
          return;
        }
        
        const categories = Array.from(categoriesGrid.children);
        if (categories.length === 0) return;
        
        // Crear contenedor m√≥vil
        const mobileContainer = document.createElement('div');
        mobileContainer.className = 'categories-mobile-container';
        
        // Crear tabs
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'categories-mobile-tabs';
        
        // Crear indicador de progreso
        const progressContainer = document.createElement('div');
        progressContainer.className = 'mobile-progress';
        progressContainer.innerHTML = `
          <div>Progreso: <span id="mobile-progress-text">0/${categories.length} completadas</span></div>
          <div class="progress-bar">
            <div class="progress-fill" id="mobile-progress-fill" style="width: 0%"></div>
          </div>
        `;
        
        // Crear contenedores de contenido
        const contentContainers = [];
        
        categories.forEach((categoryCard, index) => {
          // Extraer informaci√≥n de la categor√≠a
          const categoryTitle = categoryCard.querySelector('.category-title')?.textContent || `Cat ${index + 1}`;
          const categoryEmoji = categoryCard.querySelector('.category-emoji')?.textContent || 'üìù';
          
          // Crear tab button
          const tabButton = document.createElement('button');
          tabButton.className = `tab-button ${index === 0 ? 'active' : ''}`;
          tabButton.innerHTML = `${categoryEmoji} ${categoryTitle.split(' ')[0]}`;
          tabButton.dataset.tabIndex = index;
          
          // Crear contenedor de contenido
          const contentContainer = document.createElement('div');
          contentContainer.className = `category-tab-content ${index === 0 ? 'active' : ''}`;
          contentContainer.appendChild(categoryCard.cloneNode(true));
          
          tabsContainer.appendChild(tabButton);
          contentContainers.push(contentContainer);
          
          // Event listener para cambio de tab
          tabButton.addEventListener('click', () => switchMobileTab(index));
        });
        
        // Ensamblar estructura m√≥vil
        mobileContainer.appendChild(progressContainer);
        mobileContainer.appendChild(tabsContainer);
        contentContainers.forEach(container => mobileContainer.appendChild(container));
        
        // Reemplazar grid con versi√≥n m√≥vil
        categoriesGrid.style.display = 'none';
        categoriesGrid.parentNode.insertBefore(mobileContainer, categoriesGrid);
        
        // Inicializar progreso
        updateMobileProgress();
        
        console.log('‚úÖ [GAME.HTML] Navegaci√≥n m√≥vil inicializada');
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error inicializando tabs m√≥viles:', error);
      }
    }
    
    function switchMobileTab(index) {
      try {
        // Actualizar botones
        document.querySelectorAll('.tab-button').forEach((btn, i) => {
          btn.classList.toggle('active', i === index);
        });
        
        // Actualizar contenido
        document.querySelectorAll('.category-tab-content').forEach((content, i) => {
          content.classList.toggle('active', i === index);
        });
        
        // Haptic feedback en m√≥vil
        if (navigator.vibrate) {
          navigator.vibrate(10);
        }
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error cambiando tab m√≥vil:', error);
      }
    }
    
    function updateMobileProgress() {
      try {
        const inputs = document.querySelectorAll('.category-tab-content .word-input');
        const completed = Array.from(inputs).filter(input => input.value.trim().length > 0).length;
        const total = inputs.length;
        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        const progressText = document.getElementById('mobile-progress-text');
        const progressFill = document.getElementById('mobile-progress-fill');
        
        if (progressText) progressText.textContent = `${completed}/${total} completadas`;
        if (progressFill) progressFill.style.width = `${percentage}%`;
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error actualizando progreso m√≥vil:', error);
      }
    }
    
    // Inicializar cuando la p√°gina cargue
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeMobileTabs, 100);
      
      // Actualizar progreso cuando cambien inputs
      document.addEventListener('input', (e) => {
        if (e.target.classList.contains('word-input')) {
          updateMobileProgress();
        }
      });
    });
    
    // Funci√≥n para restaurar grid de escritorio
    function restoreDesktopGrid() {
      const categoriesGrid = document.querySelector('.categories-grid-new');
      const mobileContainer = document.querySelector('.mobile-game-container');
      
      if (categoriesGrid && mobileContainer) {
        categoriesGrid.style.display = '';
        mobileContainer.remove();
        console.log('üñ•Ô∏è [GAME.HTML] Grid de escritorio restaurado');
      }
    }
    
    // Manejar cambios de tama√±o de ventana
    window.addEventListener('resize', () => {
      const isMobile = window.innerWidth <= 480;
      const isTouch = 'ontouchstart' in window;
      const shouldUseMobile = isMobile && isTouch;
      
      if (!shouldUseMobile) {
        restoreDesktopGrid();
      } else {
        setTimeout(initializeMobileTabs, 100);
      }
    });
    
    // Reinicializar en cambio de orientaci√≥n
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        const isMobile = window.innerWidth <= 480;
        const isTouch = 'ontouchstart' in window;
        const shouldUseMobile = isMobile && isTouch;
        
        if (!shouldUseMobile) {
          restoreDesktopGrid();
        } else {
          initializeMobileTabs();
        }
      }, 300);
    });
    
    // SISTEMA DE MICRO-INTERACCIONES - FASE 4
    function initializeMicroInteractions() {
      console.log('‚ú® [GAME.HTML] Inicializando micro-interacciones...');
      
      // Animaci√≥n autom√°tica para inputs completados
      document.addEventListener('input', (e) => {
        if (e.target.classList.contains('word-input')) {
          const input = e.target;
          const hasValue = input.value.trim().length > 0;
          
          if (hasValue && !input.classList.contains('filled')) {
            input.classList.add('filled');
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(50);
          } else if (!hasValue && input.classList.contains('filled')) {
            input.classList.remove('filled');
          }
        }
      });
      
      // Animaci√≥n para categor√≠as completadas
      const checkCategoryCompletion = () => {
        document.querySelectorAll('.category-card').forEach(card => {
          const input = card.querySelector('.word-input');
          if (input && input.value.trim().length > 0) {
            card.classList.add('completed');
          } else {
            card.classList.remove('completed');
          }
        });
      };
      
      // Verificar completado cada 500ms
      setInterval(checkCategoryCompletion, 500);
      
      // Indicador de conexi√≥n
      addConnectionIndicator();
      
      // Mejorar timer con warning
      enhanceTimerAnimation();
    }
    
    function addConnectionIndicator() {
      const indicator = document.createElement('div');
      indicator.className = 'connection-status connected';
      indicator.textContent = 'üü¢ Conectado';
      document.body.appendChild(indicator);
      
      // Escuchar eventos de conexi√≥n
      if (socketManager) {
        socketManager.on('connect', () => {
          indicator.className = 'connection-status connected';
          indicator.textContent = 'üü¢ Conectado';
        });
        
        socketManager.on('disconnect', () => {
          indicator.className = 'connection-status disconnected';
          indicator.textContent = 'üî¥ Desconectado';
        });
      }
    }
    
    function enhanceTimerAnimation() {
      // Observar el timer para agregar warning cuando sea cr√≠tico
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const timerElement = document.querySelector('.timer-compact');
            if (timerElement) {
              const timeText = timerElement.textContent;
              const timeMatch = timeText.match(/(\d+)/);
              
              if (timeMatch) {
                const seconds = parseInt(timeMatch[1]);
                if (seconds <= 10 && seconds > 0) {
                  timerElement.classList.add('warning');
                } else {
                  timerElement.classList.remove('warning');
                }
              }
            }
          }
        });
      });
      
      // Observar cambios en el timer
      const timerElement = document.querySelector('.timer-compact');
      if (timerElement) {
        observer.observe(timerElement, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    }
    
    // Inicializar micro-interacciones cuando cargue la p√°gina
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeMicroInteractions, 200);
    });
    
    // FASE 4: SOCIAL PRESSURE TIMER - Sistema de presi√≥n visual
    function handleSocialPressure(data) {
      const timerElement = document.querySelector('.timer-compact');
      const gameContainer = document.querySelector('.game-container') || document.body;
      
      // Agregar clase de presi√≥n al timer
      if (timerElement) {
        timerElement.classList.add('warning');
        timerElement.style.animation = 'timerPulse 0.8s ease-in-out infinite';
      }
      
      // Mostrar notificaci√≥n de presi√≥n social
      let pressureMessage = '';
      switch (data.pressureReason) {
        case 'few_active':
          pressureMessage = `‚ö° ¬°Presi√≥n social! Solo ${data.activePlayers} jugadores activos`;
          break;
        case 'last_player':
          pressureMessage = 'üî• ¬°Eres el √∫ltimo! El tiempo se acelera';
          break;
        case 'most_completed':
          pressureMessage = '‚è∞ La mayor√≠a ha terminado. ¬°Ap√∫rate!';
          break;
        default:
          pressureMessage = '‚ö° ¬°Presi√≥n social activada!';
      }
      
      showSocialPressureNotification(pressureMessage, data.pressureMultiplier);
      
      // Efectos visuales de urgencia
      if (data.pressureMultiplier >= 2.0) {
        gameContainer.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
          gameContainer.style.animation = '';
        }, 500);
      }
      
      // Haptic feedback intenso
      if (navigator.vibrate) {
        navigator.vibrate([100, 50, 100]);
      }
      
      console.log('üî• [SOCIAL PRESSURE] Presi√≥n activada:', data);
    }
    
    function removeSocialPressure() {
      const timerElement = document.querySelector('.timer-compact');
      if (timerElement) {
        timerElement.classList.remove('warning');
        timerElement.style.animation = '';
      }
    }
    
    function showSocialPressureNotification(message, multiplier) {
      // Remover notificaci√≥n anterior si existe
      const existingNotification = document.querySelector('.social-pressure-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Crear nueva notificaci√≥n
      const notification = document.createElement('div');
      notification.className = 'social-pressure-notification';
      notification.innerHTML = `
        <div class="pressure-content">
          <div class="pressure-message">${message}</div>
          <div class="pressure-multiplier">Timer acelerado ${multiplier}x</div>
        </div>
      `;
      
      // Estilos inline para la notificaci√≥n
      notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff6b6b, #ff5252);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        z-index: 10000;
        text-align: center;
        font-weight: 600;
        border: 2px solid rgba(255, 255, 255, 0.3);
        animation: pressureNotificationIn 0.5s ease;
      `;
      
      // Agregar estilos de animaci√≥n
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pressureNotificationIn {
          0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
          }
          100% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
          }
        }
        
        .pressure-message {
          font-size: 18px;
          margin-bottom: 8px;
        }
        
        .pressure-multiplier {
          font-size: 14px;
          opacity: 0.9;
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(notification);
      
      // Auto-remover despu√©s de 3 segundos
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'pressureNotificationOut 0.3s ease forwards';
          setTimeout(() => notification.remove(), 300);
        }
      }, 3000);
    }
    
    // Mejorar el handler de timerUpdate existente si existe
    if (typeof socketManager !== 'undefined') {
      socketManager.on('timerUpdate', (data) => {
        if (data.isUnderPressure) {
          handleSocialPressure(data);
        } else {
          removeSocialPressure();
        }
      });
      
      // FASE 4: Handler para Letter Streak System - Movido a handleRoundStart principal
    }
    
    // FASE 4: LETTER STREAK SYSTEM - Indicadores visuales
    function handleLetterStreakBonus(data) {
      const currentPlayerName = localStorage.getItem('playerName');
      const playerBonus = data.streakBonuses[currentPlayerName];
      
      if (!playerBonus || playerBonus.multiplier <= 1.0) return;
      
      showLetterStreakNotification(playerBonus);
      addStreakIndicatorToLetter(playerBonus);
      
      console.log('üî• [LETTER STREAK] Bonus activado:', playerBonus);
    }
    
    function showLetterStreakNotification(bonus) {
      const notification = document.createElement('div');
      notification.className = 'letter-streak-notification';
      
      let icon = '‚ö°';
      let bgColor = '#FF9800';
      
      if (bonus.type === 'rare') {
        icon = 'üíé';
        bgColor = '#9C27B0';
      }
      
      notification.innerHTML = `
        <div class="streak-content">
          <div class="streak-icon">${icon}</div>
          <div class="streak-message">
            <div class="streak-title">¬°RACHA DE LETRAS!</div>
            <div class="streak-details">${bonus.consecutiveCount} letras ${bonus.type === 'rare' ? 'dif√≠ciles' : 'complejas'} consecutivas</div>
            <div class="streak-multiplier">+${Math.round((bonus.multiplier - 1) * 100)}% puntos extra</div>
          </div>
        </div>
      `;
      
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, ${bgColor}, ${bgColor}dd);
        color: white;
        padding: 15px 25px;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        z-index: 9999;
        border: 2px solid rgba(255, 255, 255, 0.3);
        animation: streakNotificationIn 0.6s ease;
        backdrop-filter: blur(10px);
      `;
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes streakNotificationIn {
          0% {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px) scale(0.9);
          }
          100% {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
          }
        }
        
        .streak-content {
          display: flex;
          align-items: center;
          gap: 12px;
        }
        
        .streak-icon {
          font-size: 24px;
          animation: bounce 2s ease-in-out infinite;
        }
        
        .streak-title {
          font-size: 14px;
          font-weight: 700;
          margin-bottom: 4px;
        }
        
        .streak-details {
          font-size: 12px;
          opacity: 0.9;
          margin-bottom: 2px;
        }
        
        .streak-multiplier {
          font-size: 13px;
          font-weight: 600;
          color: #ffeb3b;
        }
        
        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-3px); }
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(notification);
      
      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate([50, 100, 50]);
      }
      
      // Auto-remover despu√©s de 4 segundos
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'streakNotificationOut 0.4s ease forwards';
          setTimeout(() => notification.remove(), 400);
        }
      }, 4000);
    }
    
    function highlightSpecialLetter(letter, type) {
      const letterDisplay = document.querySelector('.current-letter-display');
      if (!letterDisplay) return;
      
      letterDisplay.classList.remove('rare-letter', 'medium-letter');
      
      if (type === 'rare') {
        letterDisplay.classList.add('rare-letter');
      } else if (type === 'medium') {
        letterDisplay.classList.add('medium-letter');
      }
    }
    
    function addStreakIndicatorToLetter(bonus) {
      const letterSection = document.querySelector('.letter-section');
      if (!letterSection) return;
      
      // Remover indicador anterior
      const existingIndicator = letterSection.querySelector('.streak-indicator');
      if (existingIndicator) {
        existingIndicator.remove();
      }
      
      // Crear nuevo indicador
      const indicator = document.createElement('div');
      indicator.className = 'streak-indicator';
      indicator.innerHTML = `
        <span class="streak-icon">${bonus.type === 'rare' ? 'üíé' : '‚ö°'}</span>
        <span class="streak-text">Racha ${bonus.consecutiveCount}x - Bonus +${Math.round((bonus.multiplier - 1) * 100)}%</span>
      `;
      
      indicator.style.cssText = `
        position: absolute;
        top: 10px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        animation: streakIndicatorPulse 2s ease-in-out infinite;
      `;
      
      letterSection.style.position = 'relative';
      letterSection.appendChild(indicator);
    }
    
    // FASE 4: SISTEMA DE ESTAD√çSTICAS - Mostrar stats del jugador
    async function showPlayerStats() {
      try {
        const playerName = localStorage.getItem('playerName');
        if (!playerName) return;
        
        const response = await fetch(`/api/stats/${encodeURIComponent(playerName)}`);
        const data = await response.json();
        
        if (!data.success) {
          console.error('Error obteniendo estad√≠sticas:', data.error);
          return;
        }
        
        const stats = data.stats;
        const global = data.global;
        
        showStatsModal(stats, global);
        
      } catch (error) {
        console.error('Error cargando estad√≠sticas:', error);
        showNotification('Error cargando estad√≠sticas', 'error');
      }
    }
    
    function showStatsModal(stats, global) {
      // Remover modal anterior si existe
      const existingModal = document.querySelector('.stats-modal');
      if (existingModal) existingModal.remove();
      
      const modal = document.createElement('div');
      modal.className = 'stats-modal';
      
      const favoriteCategory = Object.entries(stats.favoriteCategories)
        .sort(([,a], [,b]) => b - a)[0]?.[0] || 'Ninguna';
      
      modal.innerHTML = `
        <div class="stats-content">
          <div class="stats-header">
            <h2>üìä Tus Estad√≠sticas</h2>
            <button class="stats-close" onclick="this.closest('.stats-modal').remove()">‚úï</button>
          </div>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-icon">üéÆ</div>
              <div class="stat-value">${stats.gamesPlayed}</div>
              <div class="stat-label">Juegos Jugados</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-icon">üìù</div>
              <div class="stat-value">${stats.wordsCompleted}</div>
              <div class="stat-label">Palabras Escritas</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-icon">üìà</div>
              <div class="stat-value">${stats.averageWordsPerGame.toFixed(1)}</div>
              <div class="stat-label">Promedio por Juego</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-icon">‚ö°</div>
              <div class="stat-value">${stats.streakBonusesEarned}</div>
              <div class="stat-label">Rachas Conseguidas</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-icon">üî•</div>
              <div class="stat-value">${stats.socialPressuresSurvived}</div>
              <div class="stat-label">Presiones Sociales</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-icon">‚ù§Ô∏è</div>
              <div class="stat-value">${favoriteCategory}</div>
              <div class="stat-label">Categor√≠a Favorita</div>
            </div>
          </div>
          
          <div class="global-stats">
            <h3>üåç Estad√≠sticas Globales</h3>
            <div class="global-grid">
              <div class="global-stat">
                <span class="global-label">Jugadores Totales:</span>
                <span class="global-value">${global.totalPlayers}</span>
              </div>
              <div class="global-stat">
                <span class="global-label">Juegos Jugados:</span>
                <span class="global-value">${global.totalGames}</span>
              </div>
              <div class="global-stat">
                <span class="global-label">Palabras Escritas:</span>
                <span class="global-value">${global.totalWords}</span>
              </div>
              <div class="global-stat">
                <span class="global-label">Activos Hoy:</span>
                <span class="global-value">${global.activeToday}</span>
              </div>
            </div>
          </div>
        </div>
      `;
      
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
        animation: fadeIn 0.3s ease;
      `;
      
      const style = document.createElement('style');
      style.textContent = `
        .stats-content {
          background: white;
          border-radius: 20px;
          padding: 30px;
          max-width: 600px;
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .stats-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 25px;
          border-bottom: 2px solid #f0f0f0;
          padding-bottom: 15px;
        }
        
        .stats-header h2 {
          margin: 0;
          color: #333;
          font-size: 24px;
        }
        
        .stats-close {
          background: #ff6b6b;
          color: white;
          border: none;
          border-radius: 50%;
          width: 35px;
          height: 35px;
          cursor: pointer;
          font-size: 18px;
          transition: all 0.2s ease;
        }
        
        .stats-close:hover {
          background: #ff5252;
          transform: scale(1.1);
        }
        
        .stats-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        
        .stat-card {
          background: linear-gradient(135deg, #667eea, #764ba2);
          color: white;
          text-align: center;
          padding: 20px 15px;
          border-radius: 15px;
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
          transition: transform 0.2s ease;
        }
        
        .stat-card:hover {
          transform: translateY(-3px);
        }
        
        .stat-icon {
          font-size: 30px;
          margin-bottom: 10px;
        }
        
        .stat-value {
          font-size: 24px;
          font-weight: 700;
          margin-bottom: 5px;
        }
        
        .stat-label {
          font-size: 12px;
          opacity: 0.9;
        }
        
        .global-stats {
          background: #f8f9fa;
          padding: 20px;
          border-radius: 15px;
        }
        
        .global-stats h3 {
          margin: 0 0 15px 0;
          color: #333;
          font-size: 18px;
        }
        
        .global-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 10px;
        }
        
        .global-stat {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 8px 0;
          border-bottom: 1px solid #eee;
        }
        
        .global-label {
          color: #666;
          font-size: 14px;
        }
        
        .global-value {
          color: #333;
          font-weight: 600;
          font-size: 14px;
        }
        
        @media (max-width: 480px) {
          .stats-content {
            padding: 20px;
            border-radius: 15px;
          }
          
          .stats-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
          }
          
          .stat-card {
            padding: 15px 10px;
          }
          
          .stat-icon {
            font-size: 24px;
          }
          
          .stat-value {
            font-size: 20px;
          }
        }
      `;
      
      document.head.appendChild(style);
      document.body.appendChild(modal);
      
      // Cerrar con click fuera del modal
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }
    
    // Agregar bot√≥n de estad√≠sticas al header
    function addStatsButton() {
      const headerStats = document.querySelector('.header-stats');
      if (!headerStats) return;
      
      const statsButton = document.createElement('button');
      statsButton.className = 'stats-button';
      statsButton.innerHTML = 'üìä';
      statsButton.title = 'Ver estad√≠sticas';
      statsButton.onclick = showPlayerStats;
      
      statsButton.style.cssText = `
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        font-size: 16px;
        padding: 8px 12px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        backdrop-filter: blur(10px);
      `;
      
      statsButton.onmouseover = function() {
        this.style.background = 'rgba(255, 255, 255, 0.3)';
        this.style.transform = 'scale(1.05)';
      };
      
      statsButton.onmouseout = function() {
        this.style.background = 'rgba(255, 255, 255, 0.2)';
        this.style.transform = 'scale(1)';
      };
      
      headerStats.appendChild(statsButton);
    }
    
    // Inicializar bot√≥n de estad√≠sticas
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(addStatsButton, 500);
      setTimeout(addFeedbackButton, 600);
    });
    
    // FASE 4: SISTEMA DE FEEDBACK - Mostrar modal de feedback
    function showFeedbackModal() {
      // Crear modal simplificado
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 10000;
      `;
      
      modal.innerHTML = `
        <div style="
          background: white; border-radius: 20px; padding: 30px;
          max-width: 400px; width: 90%; text-align: center;
        ">
          <h2>üí¨ ¬øC√≥mo fue tu experiencia?</h2>
          <div id="rating-stars" style="margin: 20px 0;">
            <span class="star" data-rating="1" style="font-size:30px;cursor:pointer;opacity:0.3;">‚≠ê</span>
            <span class="star" data-rating="2" style="font-size:30px;cursor:pointer;opacity:0.3;">‚≠ê</span>
            <span class="star" data-rating="3" style="font-size:30px;cursor:pointer;opacity:0.3;">‚≠ê</span>
            <span class="star" data-rating="4" style="font-size:30px;cursor:pointer;opacity:0.3;">‚≠ê</span>
            <span class="star" data-rating="5" style="font-size:30px;cursor:pointer;opacity:0.3;">‚≠ê</span>
          </div>
          <textarea id="feedback-text" placeholder="Cu√©ntanos m√°s (opcional)..." 
            style="width:100%;height:60px;margin:15px 0;padding:10px;border:2px solid #ddd;border-radius:8px;"></textarea>
          <div>
            <button onclick="this.closest('div').parentElement.remove()" 
              style="background:#ddd;border:none;padding:10px 20px;margin:5px;border-radius:20px;cursor:pointer;">
              Cancelar
            </button>
            <button id="submit-feedback" disabled
              style="background:#667eea;color:white;border:none;padding:10px 20px;margin:5px;border-radius:20px;cursor:pointer;">
              üíå Enviar
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      let currentRating = 0;
      const stars = modal.querySelectorAll('.star');
      const submitBtn = modal.querySelector('#submit-feedback');
      const textArea = modal.querySelector('#feedback-text');
      
      // Manejar estrellas
      stars.forEach((star, index) => {
        star.onclick = () => {
          currentRating = index + 1;
          stars.forEach((s, i) => {
            s.style.opacity = i < currentRating ? '1' : '0.3';
          });
          submitBtn.disabled = false;
          submitBtn.style.opacity = '1';
        };
      });
      
      // Enviar feedback
      submitBtn.onclick = async () => {
        const playerName = localStorage.getItem('playerName');
        const message = textArea.value.trim();
        
        try {
          const response = await fetch('/api/feedback', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              playerName: playerName,
              rating: currentRating,
              message: message,
              type: 'game'
            })
          });
          
          const data = await response.json();
          if (data.success) {
            showNotification('¬°Gracias por tu feedback! üíô', 'success');
            modal.remove();
          }
        } catch (error) {
          showNotification('Error al enviar feedback', 'error');
        }
      };
      
      // Cerrar con click fuera
      modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
      };
    }
    
    function addFeedbackButton() {
      const headerStats = document.querySelector('.header-stats');
      if (!headerStats) return;
      
      const feedbackButton = document.createElement('button');
      feedbackButton.innerHTML = 'üí¨';
      feedbackButton.title = 'Enviar feedback';
      feedbackButton.onclick = showFeedbackModal;
      feedbackButton.style.cssText = `
        background: rgba(255,255,255,0.2); border: none; color: white;
        font-size: 16px; padding: 8px 12px; border-radius: 20px;
        cursor: pointer; transition: all 0.2s ease; backdrop-filter: blur(10px);
        margin-left: 10px;
      `;
      
      feedbackButton.onmouseover = function() {
        this.style.background = 'rgba(255,255,255,0.3)';
        this.style.transform = 'scale(1.05)';
      };
      
      feedbackButton.onmouseout = function() {
        this.style.background = 'rgba(255,255,255,0.2)';
        this.style.transform = 'scale(1)';
      };
      
      headerStats.appendChild(feedbackButton);
    }

    function checkAllWordsCompleted() {
      const wordInputs = document.querySelectorAll('.word-input');
      const allFilledBasic = Array.from(wordInputs).every(input => 
        input.disabled || input.value.trim().length > 0
      );
      
      // Habilitar bot√≥n si al menos una palabra est√° completa
      const anyCompleted = Array.from(wordInputs).some(input => 
        !input.disabled && input.value.trim().length > 0
      );
      
      // Verificar si TODAS las categor√≠as est√°n completas para mostrar ¬°BASTA!
      const allCompleted = Array.from(wordInputs).every(input => {
        if (input.disabled) return true; // Ignorar inputs deshabilitados
        const word = input.value.trim();
        const letter = gameState.currentLetter;
        
        // Debe tener contenido Y empezar con la letra correcta
        return word.length > 0 && word.charAt(0).toUpperCase() === letter;
      });
      
      if (submitWordButton) {
        submitWordButton.disabled = !anyCompleted;
      }
      
      // Mostrar bot√≥n ¬°BASTA! solo si TODO est√° completo
      if (bastaButton) {
        if (allCompleted && gameState.isPlaying && gameState.currentLetter) {
          bastaButton.style.display = 'inline-block';
          bastaButton.classList.add('btn--pulse'); // Efecto visual
        } else {
          bastaButton.style.display = 'none';
          bastaButton.classList.remove('btn--pulse');
        }
      }
    }

    function submitWordsClassic() {
      const words = {};
      let hasValidWords = false;
      let hasInvalid = false;

      // Recopilar palabras leyendo la grilla din√°mica renderizada (no depender de constantes)
      const inputs = document.querySelectorAll('.word-input');
      inputs.forEach((input) => {
        const category = input.getAttribute('data-category');
        if (!category) return;

        const word = (input.value || '').trim();
        words[category] = word;

        if (word) {
          hasValidWords = true;

          // Validar que comience con la letra correcta
          if (gameState.currentLetter && !validateWord(word, gameState.currentLetter)) {
            hasInvalid = true;
            showNotification(
              `La palabra "${word}" debe comenzar con la letra "${gameState.currentLetter}" para la categor√≠a "${category}"`,
              'error'
            );
            try { input.focus(); } catch (_) {}
          }
        }
      });

      if (hasInvalid) {
        return; // Abortamos el env√≠o si hay alguna entrada inv√°lida
      }

      if (!hasValidWords) {
        showNotification('Debes ingresar al menos una palabra', 'warning');
        return;
      }
      
      // Enviar las palabras al servidor
      socketManager.submitWords(gameState.roomId, gameState.username, words);
      
      // Deshabilitar campos y bot√≥n
      gameState.disableInputs();
      
      // Mostrar mensaje de confirmaci√≥n
      document.getElementById('selectedLetter').textContent = 'Palabras enviadas. Esperando a los dem√°s jugadores...';
      uiManager.announce('Palabras enviadas correctamente');
      showNotification('¬°Palabras enviadas!', 'success');
    }

    function clearWordInputs() {
      // Limpiar inputs din√°micos
      const wordInputs = document.querySelectorAll('.word-input');
      wordInputs.forEach(input => {
        input.value = '';
      });

      // Limpiar displays si existen (compatibilidad con layout anterior)
      document.querySelectorAll('.word-display').forEach((displayDiv) => {
        displayDiv.classList.remove('valid', 'invalid', 'empty');
        displayDiv.classList.add('empty');
        const text = displayDiv.querySelector('.word-text');
        if (text) text.textContent = '';
      });
    }

    function showGameResults(results) {
      // Crear modal de resultados finales
      const modal = uiManager.createModal('gameResults', 'Resultados Finales');
      
      let resultsHTML = '<h3>üèÜ Clasificaci√≥n Final</h3>';
      
      // Ordenar por puntuaci√≥n
      const sortedResults = results.sort((a, b) => b.score - a.score);
      
      resultsHTML += '<div class="final-scores">';
      sortedResults.forEach((player, index) => {
        const position = index + 1;
        const emoji = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : 'üèÖ';
        
        resultsHTML += `
          <div class="final-score-item ${position === 1 ? 'winner' : ''}">
            <span class="position">${emoji} ${position}¬∞</span>
            <span class="player-name">${player.name}</span>
            <span class="final-score">${player.score} puntos</span>
          </div>
        `;
      });
      resultsHTML += '</div>';
      
      // Botones de acci√≥n
      resultsHTML += `
        <div class="game-end-actions">
          <button type="button" class="btn btn--primary" onclick="location.reload()">
            üîÑ Jugar de nuevo
          </button>
          <button type="button" class="btn btn--secondary" onclick="location.href='${ROUTES.HOME}'">
            üè† Volver al inicio
          </button>
        </div>
      `;
      
      modal.querySelector('.modal__body').innerHTML = resultsHTML;
      uiManager.openModal('gameResults');
      
      // Agregar estilos espec√≠ficos
      const style = document.createElement('style');
      style.textContent = `
        .final-scores {
          display: grid;
          gap: var(--space-3);
          margin: var(--space-6) 0;
        }
        
        .final-score-item {
          display: flex;
          align-items: center;
          gap: var(--space-3);
          padding: var(--space-4);
          background: var(--color-gray-50);
          border-radius: var(--radius-lg);
          border: 2px solid var(--color-gray-200);
        }
        
        .final-score-item.winner {
          background: linear-gradient(135deg, #ffd700, #ffed4e);
          border-color: #ffd700;
          font-weight: var(--font-weight-semibold);
        }
        
        .position {
          font-size: var(--text-lg);
          min-width: 60px;
        }
        
        .player-name {
          flex: 1;
          font-weight: var(--font-weight-medium);
        }
        
        .final-score {
          font-weight: var(--font-weight-bold);
          color: var(--color-primary);
        }
        
        .game-end-actions {
          display: flex;
          gap: var(--space-3);
          justify-content: center;
          margin-top: var(--space-6);
        }
      `;
      document.head.appendChild(style);
    }

    // Limpieza al salir de la p√°gina
    window.addEventListener('beforeunload', () => {
      gameState.clearTimer();
      socketManager.disconnect();
    });
  </script>
</body>
</html>
