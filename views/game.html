<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Jugar Tutifrutti - Completa las categorías con palabras que empiecen con la letra seleccionada">
  <title>Juego - Tutifrutti</title>
  
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/base.css">
  <link rel="stylesheet" href="/public/css/components.css">
  <link rel="stylesheet" href="/public/css/game.css">
  <link rel="stylesheet" href="/public/css/game-nextgen.css">
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>
</head>
<body class="game-layout">
  <!-- Header del juego - NUEVO DISEÑO COMPACTO -->
  <header class="game-header-compact">
    <div class="container">
      <div class="header-stats">
        <span class="app-name">🍎 TUTTI FRUTTI</span>
        <span class="timer-compact">⏱️ <span id="timerDisplay">60s</span></span>
        <span class="players-compact">👥 <span id="playersCount">0/5</span></span>
        <span class="score-compact">💯 <span id="userScore">0</span></span>
      </div>
    </div>
  </header>
  
  <!-- Letter Display - PROMINENTE Y CENTRADA -->
  <section class="letter-section">
    <div class="container">
      <div class="current-letter-display">
        🔥 <span id="letterDisplay">?</span> 🔥
      </div>
      <div class="letter-label">Letra de esta ronda</div>
    </div>
  </section>

  <!-- Contenido principal -->
  <main id="main-content" class="game-main">
    <!-- Panel de estado del juego -->
    <section class="game-status">
      <div class="status-message" id="selectedLetter" aria-live="polite">
        Esperando que comience el juego...
      </div>
    </section>

    <!-- Área de juego -->
    <section class="game-area">
      <!-- Rejilla dinámica de categorías - GRID 4x3 RESPONSIVE -->
      <div class="categories-grid-new" id="categoriesGrid" role="group" aria-label="Categorías del juego">
        <!-- Se renderiza dinámicamente con uiManager.renderCategoriesGrid -->
      </div>
    </section>

    <!-- Panel de puntuación -->
    <section class="score-panel">
      <h2 class="score-title">
        <span aria-hidden="true">📊</span>
        Puntuación
      </h2>
      <div class="score-grid" role="group" aria-label="Puntuaciones actuales">
        <div class="score-item">
          <span class="score-label">Repetidas</span>
          <span class="score-value" id="score-repetidas" aria-label="Puntos por palabras repetidas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">Únicas x2</span>
          <span class="score-value" id="score-unicas" aria-label="Puntos por palabras únicas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">+3 Sílabas x3</span>
          <span class="score-value" id="score-silabas" aria-label="Puntos por palabras con más de 3 sílabas">0</span>
        </div>
        <div class="score-item total">
          <span class="score-label">Total</span>
          <span class="score-value" id="score-total" aria-label="Puntuación total">0</span>
        </div>
      </div>
    </section>

    <!-- Controles del juego - NUEVA BARRA FIJA -->
    <section class="game-controls-fixed">
      <div class="container">
        <div class="controls-row">
          <button id="startGameButton" 
                  class="btn btn--primary btn--lg" 
                  style="display: none;"
                  aria-describedby="start-game-help">
            <span aria-hidden="true">🎮</span>
            Iniciar Juego
          </button>
          <div id="start-game-help" class="sr-only">
            Solo el anfitrión puede iniciar el juego
          </div>
          
          <button id="submitWordButton" 
                  class="btn btn--success btn--lg" 
                  disabled
                  aria-describedby="submit-words-help">
            <span aria-hidden="true">🚀</span>
            Enviar Palabras
          </button>
          <div id="submit-words-help" class="sr-only">
            Envía tus palabras cuando hayas terminado o se acabe el tiempo
          </div>
          
          <button id="bastaButton" 
                  class="btn btn--accent btn--lg" 
                  style="display: none;"
                  aria-describedby="basta-help">
            <span aria-hidden="true">⚡</span>
            ¡BASTA!
          </button>
          <div id="basta-help" class="sr-only">
            Termina la ronda inmediatamente cuando hayas completado todas las categorías
          </div>
          
          <button id="surrenderButton" 
                  class="btn btn--ghost btn--lg" 
                  style="display: none;"
                  aria-describedby="surrender-help">
            <span aria-hidden="true">⏭️</span>
            Rendirse
          </button>
          <div id="surrender-help" class="sr-only">
            Rendirse en esta ronda
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Scripts -->
  <script type="module">
    import { socketManager } from '/public/js/socket-manager.js';
    import { gameState } from '/public/js/game-state.js';
    import { uiManager } from '/public/js/ui-manager.js';
    import { storage, validateWord, showNotification } from '/utils/helpers.js';
    import { SOCKET_EVENTS, ROUTES, GAME_CONFIG } from '/utils/constants.js';

    // Referencias a elementos
    const startGameButton = document.getElementById('startGameButton');
    const submitWordButton = document.getElementById('submitWordButton');
    const bastaButton = document.getElementById('bastaButton');
    const surrenderButton = document.getElementById('surrenderButton');
    const letterDisplay = document.getElementById('letterDisplay');
    const userScoreElement = document.getElementById('userScore');

    // Exponer para acceso global
    window.gameModule = {
      submitWords: submitWordsClassic
    };

    // Inicialización
    init();

    function init() {
      // Verificar usuario y sala
      const username = storage.getUsername();
      const urlParams = new URLSearchParams(window.location.search);
      const roomId = urlParams.get('roomId') || storage.getCurrentRoomId();

      if (!username) {
        showNotification('Debes ingresar tu nombre primero', 'error');
        window.location.href = ROUTES.HOME;
        return;
      }

      if (!roomId) {
        showNotification('No se especificó una sala válida', 'error');
        window.location.href = ROUTES.CREATE_ROOM;
        return;
      }

      // Configurar estado del juego
      gameState.username = username;
      gameState.roomId = roomId;

      // Actualizar UI inicial
      if (userScoreElement) {
        userScoreElement.textContent = '0';
      }

      // Inicializar componentes
      uiManager.init();
      
      // Conectar socket y configurar eventos
      socketManager.connect();
      window.socketManager = socketManager;
      setupSocketListeners();
      setupEventListeners();
      attachWordInputEvents();

      // NO unirse nuevamente - ya estamos unidos desde la sala de espera
      // En su lugar, solicitar el estado actual de la sala
      requestRoomState(roomId);

      console.log('Juego inicializado:', { username, roomId });
    }

    function requestRoomState(roomId) {
      // Verificar si venimos de la sala de espera (evitar doble unión)
      const cameFromWaitingRoom = document.referrer.includes('join-room.html') || 
                                  document.referrer.includes('create-room.html');
      
      // Siempre intentar rehidratar estado vía getRoomState y reconectar internamente
      socketManager.getRoomState({ roomId });
      console.log('Solicitando estado de sala');
    }

    function setupEventListeners() {
      // Botón iniciar juego - NUEVO FLUJO: Auto-letter inmediata
      startGameButton?.addEventListener('click', () => {
        if (gameState.isHost) {
          startGameButton.disabled = true;
          startGameButton.innerHTML = '<span class="spinner"></span> Iniciando...';
          socketManager.startGame(gameState.roomId);
          showNotification('¡Iniciando juego con letra automática!', 'info');
        } else {
          showNotification('Solo el anfitrión puede iniciar el juego', 'warning');
        }
      });

      // Botón enviar palabras
      submitWordButton?.addEventListener('click', submitWordsClassic);
      
      // Botón ¡BASTA! - Termina la ronda inmediatamente
      bastaButton?.addEventListener('click', () => {
        console.log('🔥 ¡BASTA! presionado - terminando ronda inmediatamente');
        
        // Enviar palabras y forzar fin de ronda
        submitWordsClassic();
        
        // Notificar al servidor que se terminó la ronda
        socketManager.emit('forceEndRound', { 
          roomId: gameState.roomId,
          playerName: gameState.username 
        });
        
        showNotification('¡Has terminado la ronda!', 'success');
        
        // Ocultar botón después de usar
        bastaButton.style.display = 'none';
      });
      
      // Botón rendirse
      surrenderButton?.addEventListener('click', () => {
        if (confirm('¿Estás seguro de que quieres rendirte en esta ronda?')) {
          submitWordsClassic(); // Envía palabras actuales
          showNotification('Te has rendido en esta ronda', 'info');
        }
      });
    }

    function attachWordInputEvents() {
      const wordInputs = document.querySelectorAll('.word-input');
      
      wordInputs.forEach((input, index) => {
        // Navegación con Enter
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            moveToNextCategory(index);
          }
          
          // Enviar con Ctrl+Enter
          if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            submitWordsClassic();
          }
        });

        // Validación en tiempo real con restricción de letra
        input.addEventListener('input', function() {
          const category = this.getAttribute('data-category');
          let word = this.value.trim();
          
          // NUEVA VALIDACIÓN: Bloquear primera letra incorrecta
          if (word.length > 0 && gameState.currentLetter) {
            const firstChar = normalizeFirstLetter(word.charAt(0));
            const targetLetter = gameState.currentLetter.toUpperCase();
            
            if (firstChar !== targetLetter) {
              // Bloquear entrada - remover último carácter
              this.value = word.slice(0, -1);
              word = this.value.trim();
              
              // Feedback visual de error
              this.classList.add('blocked');
              setTimeout(() => this.classList.remove('blocked'), 200);
              
              // Mostrar mensaje de error temporal
              showTemporaryError(this, `Debe empezar con "${targetLetter}"`);
              return;
            }
          }
          
          // No validar automáticamente - la validación se hace en revisión social
          const hasContent = word && word.length > 0;
          
          // Actualizar visualización sin validación automática
          updateCategoryCardState(this, category, word, hasContent);
          
          // Verificar si todas las palabras están completas
          checkAllWordsCompleted();
        });

        // Gestión del foco
        input.addEventListener('focus', function() {
          uiManager.setActiveInput(this);
        });

        input.addEventListener('blur', function() {
          uiManager.removeActiveInput(this);
        });
      });
    }

    function setupSocketListeners() {
      // Conexión y errores
      socketManager.on(SOCKET_EVENTS.JOINED_ROOM, handleJoinedRoom);
      socketManager.on(SOCKET_EVENTS.PLAYER_JOINED, handlePlayerJoined);
      socketManager.on(SOCKET_EVENTS.PLAYER_LEFT, handlePlayerLeft);
      
      // Estado de la sala
      socketManager.on(SOCKET_EVENTS.ROOM_STATE, handleRoomState);
      
      // Juego - NUEVO FLUJO: Solo ROUND_START
      socketManager.on(SOCKET_EVENTS.ROUND_START, handleRoundStart);
      socketManager.on(SOCKET_EVENTS.START_REVIEW, handleStartReview);
      socketManager.on(SOCKET_EVENTS.TIMER_UPDATE, handleTimerUpdate);
      socketManager.on(SOCKET_EVENTS.ROUND_ENDED, handleRoundEnded);
      socketManager.on(SOCKET_EVENTS.GAME_ENDED, handleGameEnded);

      // Eventos futuros (validación social)
      // Ya configurado arriba
      socketManager.on(SOCKET_EVENTS.VOTE_UPDATE, handleVoteUpdate);
      socketManager.on(SOCKET_EVENTS.REVIEW_ENDED, handleReviewEnded);

      // Eventos de host
      socketManager.on(SOCKET_EVENTS.YOU_ARE_CREATOR, () => {
        gameState.setHost(true);
        const startButton = document.getElementById('startGameButton');
        if (startButton) startButton.style.display = 'block';
      });
    }

    function handleRoomState(data) {
      console.log('Estado de la sala recibido:', data);
      
      if (!data || !data.players) {
        console.error('Estado de sala inválido:', data);
        showNotification('Error al cargar el estado de la sala', 'error');
        return;
      }
      
      // Actualizar estado del juego
      gameState.updatePlayers(data.players);
      
      // Verificar si el jugador actual es el creador
      const currentPlayer = data.players.find(p => p.name === gameState.username);
      const isCreator = currentPlayer ? currentPlayer.isCreator : false;
      gameState.setHost(isCreator);
      
      console.log(`Jugador actual: ${gameState.username}, Es creador: ${isCreator}`);
      
      // NUEVO FLUJO: Sin ruleta, directo a juego si está en curso
      if (data.isPlaying) {
        gameState.startGame();
        if (data.currentLetter) {
          // Juego en curso con letra: renderizar categorías y mostrar letra
          displayCurrentLetter(data.currentLetter);
          uiManager.renderCategoriesGrid(data.categories || GAME_CONFIG.CATEGORIES);
          attachWordInputEvents();
          gameState.setCurrentLetter(data.currentLetter);
          document.getElementById('selectedLetter').textContent = `¡Escribiendo con la letra ${data.currentLetter}!`;
        } else {
          // Juego en curso sin letra: estado transitorio, esperar ROUND_START
          document.getElementById('selectedLetter').textContent = 'Generando letra automática...';
        }
        if (startGameButton) startGameButton.style.display = 'none';
      } else if (isCreator) {
        // Mostrar botón de iniciar juego si es el creador y el juego no ha empezado
        if (startGameButton) {
          startGameButton.style.display = 'block';
        }
        document.getElementById('selectedLetter').textContent = '¡Haz clic en "Iniciar Juego" para comenzar!';
        uiManager.announce('Eres el anfitrión. Puedes iniciar el juego cuando estés listo.');
      } else {
        document.getElementById('selectedLetter').textContent = 'Esperando que el anfitrión inicie el juego...';
      }
      
      uiManager.announce(`Estado del juego cargado. ${data.players.length} jugadores en la sala.`);
      showNotification('¡Listo para jugar!', 'success');
    }

    function handleJoinedRoom(data) {
      console.log('Unido a la sala:', data);
      
      gameState.updatePlayers(data.players || []);
      const isCreator = data.isCreator || false;
      gameState.setHost(isCreator);
      
      console.log(`Unido a sala - Es creador: ${isCreator}`);
      
      // Si es el creador, mostrar controles apropiados
      if (isCreator) {
        const startButton = document.getElementById('startGameButton');
        if (startButton) {
          startButton.style.display = 'block';
        }
        uiManager.announce('Eres el anfitrión de esta sala.');
      }
      
      uiManager.announce(`Te has unido a la sala. Hay ${data.players?.length || 0} jugadores.`);
    }

    function handlePlayerJoined(data) {
      console.log('Jugador se unió:', data);
      if (data && data.players) {
        gameState.updatePlayers(data.players);
      }
      const playerName = data?.player?.name;
      if (playerName && playerName !== gameState.username) {
        uiManager.announce(`${playerName} se unió al juego`);
        showNotification(`${playerName} se unió al juego`, 'info');
      }
    }

    function handlePlayerLeft(data) {
      console.log('Jugador se fue:', data);
      
      if (data.players) {
        gameState.updatePlayers(data.players);
        
        if (data.playerName && data.playerName !== gameState.username) {
          uiManager.announce(`${data.playerName} dejó el juego`);
          showNotification(`${data.playerName} dejó el juego`, 'info');
        }
      }
    }

    // NUEVA FUNCIÓN: Mostrar letra en header compacto
    function displayCurrentLetter(letter) {
      if (letterDisplay) {
        letterDisplay.textContent = letter;
      }
      // También actualizar en el panel de estado
      const statusMessage = document.getElementById('selectedLetter');
      if (statusMessage) {
        statusMessage.textContent = `¡Escribiendo con la letra ${letter}!`;
      }
      uiManager.announce(`Letra seleccionada: ${letter}. ¡A escribir!`);
    }

    // FUNCIÓN: Normalizar primera letra (tildes + Ñ)
    function normalizeFirstLetter(char) {
      const normalized = char.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      return normalized.toUpperCase();
    }

    // FUNCIÓN: Mostrar error temporal en input
    function showTemporaryError(input, message) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Crear elemento de error temporal
      const errorEl = document.createElement('div');
      errorEl.className = 'temp-error';
      errorEl.textContent = message;
      errorEl.style.cssText = `
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--color-error);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        animation: errorPulse 2s ease-out forwards;
      `;
      
      card.style.position = 'relative';
      card.appendChild(errorEl);
      
      setTimeout(() => {
        if (errorEl.parentNode) {
          errorEl.parentNode.removeChild(errorEl);
        }
      }, 2000);
    }

    // FUNCIÓN: Actualizar estado visual de categoria card (SIN validación automática)
    function updateCategoryCardState(input, category, word, hasContent) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Limpiar clases previas
      card.classList.remove('completed', 'invalid', 'empty', 'filled');
      input.classList.remove('valid', 'invalid', 'filled');
      
      if (hasContent) {
        // Solo marcar como "filled" sin validar
        card.classList.add('filled');
        input.classList.add('filled');
      } else {
        card.classList.add('empty');
      }
      
      // Actualizar feedback visual sin validación
      updateCategoryFeedback(card, word, hasContent);
    }

    // FUNCIÓN: Feedback visual en categoria card (SIN validación automática)
    function updateCategoryFeedback(card, word, hasContent) {
      let feedbackEl = card.querySelector('.category-card__feedback');
      
      if (hasContent) {
        if (!feedbackEl) {
          feedbackEl = document.createElement('div');
          feedbackEl.className = 'category-card__feedback';
          card.appendChild(feedbackEl);
        }
        
        // Solo mostrar que tiene contenido, sin validar
        feedbackEl.className = 'category-card__feedback filled';
        feedbackEl.textContent = '📝';
        feedbackEl.setAttribute('aria-label', 'Palabra ingresada');
      } else if (feedbackEl) {
        feedbackEl.remove();
      }
    }

    // NUEVO FLUJO: Round start con auto-letter inmediata
    function handleRoundStart(data) {
      try {
        console.log('[Game] handleRoundStart - NUEVO FLUJO:', data);
        
        const categories = data?.categories || GAME_CONFIG.CATEGORIES;
        
        // Ocultar botón de iniciar juego
        if (startGameButton) startGameButton.style.display = 'none';
        
        // Mostrar letra en header compacto
        displayCurrentLetter(data.letter);
        
        // Render de categorías dinámicas en grid 4x3
        uiManager.renderCategoriesGrid(categories);
        attachWordInputEvents();
        
        // Configurar estado del juego
        gameState.setCurrentLetter(data.letter);
        gameState.enableInputs();
        gameState.startGame();

        // Mostrar botón de rendirse durante el juego
        if (surrenderButton) {
          surrenderButton.style.display = 'inline-block';
        }

        // Enfocar primer input disponible para UX
        setTimeout(() => {
          const first = document.querySelector('.word-input:not([disabled])');
          if (first) { 
            try { first.focus(); } catch(_) {} 
          }
        }, 100);

        showNotification(`¡Ronda ${data.round} iniciada con letra ${data.letter}!`, 'success');
        uiManager.announce(`Ronda ${data.round} iniciada con letra ${data.letter}. ¡Tiempo para escribir!`);
      } catch (e) {
        console.error('Error en handleRoundStart:', e);
        showNotification('Error al iniciar la ronda', 'error');
      }
    }

    function handleStartReview(data) {
      try {
        console.log('🔄 [GAME.HTML] Iniciando revisión social:', data);
        console.log('🔄 [GAME.HTML] Estado actual del juego:', {
          roomId: gameState.roomId,
          isPlaying: gameState.isPlaying,
          timeRemaining: gameState.timeRemaining
        });
        
        // Bloquear entradas y botón de enviar
        gameState.disableInputs();
        if (submitWordButton) submitWordButton.disabled = true;
        
        // Mostrar notificación de transición
        showNotification(data.message || '¡Hora de revisar las palabras!', 'info');
        
        // SOLUCIÓN DEFINITIVA: Implementar revisión 100% NATIVA
        try {
          console.log('🔄 [GAME.HTML] Implementando revisión NATIVA - SIN redirección...');
          
          // Ocultar interfaz de juego
          const gameContainer = document.querySelector('.game-container');
          if (gameContainer) {
            gameContainer.style.display = 'none';
          }
          
          // Implementar interfaz de revisión directamente
          implementNativeReviewInterface(data);
          
        } catch (error) {
          console.error('❌ [GAME.HTML] Error implementando revisión nativa:', error);
          showNotification('Error al implementar revisión', 'error');
        }
        
      } catch (e) {
        console.error('Error en handleStartReview:', e);
        showNotification('Error al iniciar la revisión', 'error');
      }
    }

    function handleVoteUpdate(data) {
      try {
        uiManager.updateVoteCounts(data);
      } catch (e) {
        console.error('Error en handleVoteUpdate:', e);
      }
    }

    function handleReviewEnded(data) {
      try {
        // Cerrar modal de revisión; los resultados llegarán por ROUND_ENDED
        uiManager.closeReviewModal();
      } catch (e) {
        console.error('Error en handleReviewEnded:', e);
      }
    }

    function handleTimerUpdate(data) {
      gameState.timeRemaining = data.timeRemaining;
      gameState.updateTimerDisplay();
      
      // Advertencia cuando queden pocos segundos
      if (data.timeRemaining <= 10 && data.timeRemaining > 0) {
        if (data.timeRemaining <= 5) {
          uiManager.announce(`¡${data.timeRemaining} segundos!`);
        }
      }
      if (data.timeRemaining <= 0) {
        // Evitar acciones locales; el servidor cerrará la ronda
        gameState.clearTimer();
      }
    }

    function handleRoundEnded(data) {
      console.log('[Game] handleRoundEnded ->', data);
      
      gameState.clearTimer();
      gameState.disableInputs();
      gameState.updatePlayerScore(data.scores);
      
      // Mostrar resultados
      uiManager.showRoundResults(data);
      
      // Limpiar campos para la siguiente ronda
      clearWordInputs();
      
      uiManager.announce('La ronda ha terminado. Revisa los resultados.');
      
      // Preparar para la siguiente ronda: esperar ROUND_START del servidor
      const selectedLetterEl = document.getElementById('selectedLetter');
      if (selectedLetterEl) {
        selectedLetterEl.textContent = 'Esperando siguiente ronda...';
      }
    }

    function handleGameEnded(data) {
      console.log('Juego terminado:', data);
      
      gameState.clearTimer();
      gameState.gameStarted = false;
      
      // Mostrar resultados finales
      showGameResults(data.results);
      
      uiManager.announce('El juego ha terminado. Revisa los resultados finales.');
    }

    function moveToNextCategory(currentIndex) {
      const wordInputs = document.querySelectorAll('.word-input');
      const nextIndex = (currentIndex + 1) % wordInputs.length;
      
      if (nextIndex < wordInputs.length && !wordInputs[nextIndex].disabled) {
        wordInputs[nextIndex].focus();
      }
    }
    
    // SOLUCIÓN DEFINITIVA: Implementar revisión 100% NATIVA
    function implementNativeReviewInterface(data) {
      try {
        console.log('🔄 [GAME.HTML] Creando interfaz de revisión NATIVA...');
        
        // Crear contenedor de revisión manteniendo la ESENCIA del proyecto
        const reviewContainer = document.createElement('div');
        reviewContainer.id = 'native-review-container';
        reviewContainer.innerHTML = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          ">
            <!-- Header del juego manteniendo nuestro estilo -->
            <div style="
              text-align: center;
              color: white;
              margin-bottom: 30px;
            ">
              <h2 style="font-size: 32px; margin: 0 0 10px 0; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                🔍 Revisión Social de Palabras
              </h2>
              <div style="
                display: flex;
                justify-content: center;
                gap: 30px;
                font-size: 18px;
                font-weight: 600;
                text-shadow: 0 1px 2px rgba(0,0,0,0.3);
              ">
                <span>Ronda: <strong>${data.round || 1}</strong></span>
                <span>Letra: <strong>${data.letter || 'X'}</strong></span>
              </div>
            </div>
            
            <!-- Panel de instrucciones con nuestro estilo -->
            <div style="
              background: rgba(255, 255, 255, 0.95);
              border-radius: 12px;
              padding: 20px;
              margin: 0 auto 25px;
              max-width: 700px;
              color: #333;
              font-size: 16px;
              text-align: center;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
              border: 2px solid rgba(255,255,255,0.3);
            ">
              <strong>📊 Sistema de Votación Social:</strong><br>
              Vota si cada palabra es válida (✓) o inválida (✗). Los resultados se decidirán por consenso.
            </div>
            
            <!-- Panel principal manteniendo nuestro estilo -->
            <div style="
              background: rgba(255, 255, 255, 0.98);
              border-radius: 15px;
              padding: 30px;
              margin: 0 auto;
              max-width: 1000px;
              box-shadow: 0 8px 25px rgba(0,0,0,0.2);
              border: 2px solid rgba(255,255,255,0.3);
            ">
              <div id="review-status" style="
                text-align: center;
                color: #666;
                margin-bottom: 25px;
                font-size: 16px;
              ">Esperando datos de revisión...</div>
              
              <!-- Contenedor de votación -->
              <div id="players-voting-container">
                <!-- Se llenará dinámicamente -->
              </div>
              
              <!-- Botón de confirmación con nuestro estilo -->
              <div style="text-align: center; margin-top: 30px;">
                <button id="confirm-votes-btn" style="
                  background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                  color: white;
                  border: none;
                  padding: 15px 40px;
                  border-radius: 25px;
                  font-size: 18px;
                  font-weight: 600;
                  cursor: pointer;
                  box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                  transition: all 0.3s ease;
                  text-transform: uppercase;
                  letter-spacing: 1px;
                " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(76, 175, 80, 0.5)'"
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.4)'">
                  ✅ Confirmar Votación
                </button>
              </div>
            </div>
            
            <!-- Controles de emergencia -->
            <div style="
              position: fixed;
              bottom: 20px;
              right: 20px;
              background: rgba(255, 255, 255, 0.9);
              padding: 12px;
              border-radius: 12px;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            ">
              <button id="skip-review-btn" style="
                background: #FF9800;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s ease;
              " onmouseover="this.style.background='#F57C00'"
                 onmouseout="this.style.background='#FF9800'">
                ⏭️ Saltar
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(reviewContainer);
        
        // Configurar handlers de la revisión nativa
        setupNativeReviewHandlers(data);
        
        // Solicitar datos de revisión al servidor
        socketManager.emit('getRoomState', { roomId: gameState.roomId });
        
        console.log('✅ [GAME.HTML] Interfaz de revisión NATIVA implementada');
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error en implementNativeReviewInterface:', error);
        showNotification('Error al implementar revisión nativa', 'error');
      }
    }
    
    // Configurar handlers para la revisión nativa
    function setupNativeReviewHandlers(data) {
      try {
        // Handler para confirmar votación
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          confirmBtn.addEventListener('click', () => {
            console.log('🔄 [GAME.HTML] Usuario confirmó votación...');
            confirmVotingResults();
          });
        }
        
        // Handler para saltar revisión (emergencia)
        const skipBtn = document.getElementById('skip-review-btn');
        if (skipBtn) {
          skipBtn.addEventListener('click', () => {
            console.log('🔄 [GAME.HTML] Usuario eligió saltar revisión...');
            showNotification('Saltando revisión...', 'info');
            finishNativeReview();
          });
        }
        
        // Escuchar eventos de revisión del servidor
        socketManager.on('reviewData', handleNativeReviewData);
        socketManager.on('reviewEnded', handleNativeReviewEnded);
        socketManager.on('roomState', handleNativeRoomState);
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error configurando handlers:', error);
      }
    }
    
    // Handler para datos de revisión - Sistema de votación con esencia del proyecto
    function handleNativeReviewData(data) {
      try {
        console.log('📊 [GAME.HTML] Datos de revisión recibidos:', data);
        
        const statusDiv = document.getElementById('review-status');
        if (statusDiv) {
          statusDiv.innerHTML = `
            <div style="color: #4CAF50; font-weight: 600; margin-bottom: 10px;">
              ✅ ¡Datos de revisión cargados correctamente!
            </div>
            <div>
              ${data.players?.length || 0} jugadores • ${data.players?.[0]?.words?.length || 0} categorías • Letra <strong>${data.letter}</strong>
            </div>
          `;
        }
        
        // Contenedor principal de votación
        const votingContainer = document.getElementById('players-voting-container');
        if (!votingContainer || !data.players) return;
        
        votingContainer.innerHTML = '';
        
        // Crear grid de palabras organizado por categorías (manteniendo nuestro estilo)
        const categories = [...new Set(data.players.flatMap(p => p.words?.map(w => w.category) || []))];
        
        categories.forEach((category, categoryIndex) => {
          const categorySection = document.createElement('div');
          categorySection.style.cssText = `
            margin-bottom: 35px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(102, 126, 234, 0.2);
          `;
          
          // Título de categoría con nuestro estilo
          categorySection.innerHTML = `
            <div style="
              text-align: center;
              margin-bottom: 20px;
              padding: 15px;
              background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
              border-radius: 10px;
              border: 1px solid rgba(102, 126, 234, 0.3);
            ">
              <h3 style="
                font-size: 22px;
                font-weight: 700;
                color: #333;
                margin: 0;
                text-transform: uppercase;
                letter-spacing: 1px;
              ">
                📝 ${category}
              </h3>
              <div style="font-size: 14px; color: #666; margin-top: 5px;">
                Letra: <strong style="color: #667eea;">${data.letter}</strong>
              </div>
            </div>
          `;
          
          // Grid de jugadores para esta categoría
          const playersGrid = document.createElement('div');
          playersGrid.style.cssText = `
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
          `;
          
          data.players.forEach((player, playerIndex) => {
            const word = player.words?.find(w => w.category === category);
            if (!word) return;
            
            const playerVoteCard = document.createElement('div');
            playerVoteCard.style.cssText = `
              background: white;
              border: 2px solid #e0e0e0;
              border-radius: 15px;
              padding: 20px;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            `;
            
            // Avatares simples pero consistentes con nuestro estilo
            const playerColors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#fa709a', '#fee140'];
            const playerColor = playerColors[playerIndex % playerColors.length];
            const playerInitial = player.name.charAt(0).toUpperCase();
            
            playerVoteCard.innerHTML = `
              <!-- Header del jugador -->
              <div style="
                display: flex;
                align-items: center;
                gap: 15px;
                margin-bottom: 15px;
                padding-bottom: 15px;
                border-bottom: 2px solid #f0f0f0;
              ">
                <div style="
                  width: 45px;
                  height: 45px;
                  background: linear-gradient(135deg, ${playerColor}, ${playerColor}cc);
                  border-radius: 50%;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 20px;
                  font-weight: bold;
                  color: white;
                  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                ">
                  ${playerInitial}
                </div>
                <div>
                  <div style="font-weight: 700; color: #333; font-size: 18px;">
                    ${player.name}
                  </div>
                  <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 0.5px;">
                    Jugador ${playerIndex + 1}
                  </div>
                </div>
              </div>
              
              <!-- Palabra con nuestro estilo -->
              <div style="
                background: linear-gradient(135deg, #f8f9ff, #f0f4ff);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 20px;
                border: 2px solid #e8edff;
                text-align: center;
              ">
                <div style="
                  font-size: 24px;
                  font-weight: 700;
                  color: #333;
                  min-height: 30px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                ">
                  ${word.word || '(sin respuesta)'}
                </div>
              </div>
              
              <!-- Sistema de votación adaptado -->
              <div style="
                display: flex;
                gap: 15px;
                justify-content: center;
                align-items: center;
              ">
                <!-- Botón VÁLIDA -->
                <button 
                  id="vote-valid-${player.name}-${category}"
                  onclick="castVoteForWord('${player.name}', '${category}', true)"
                  style="
                    background: linear-gradient(135deg, #4CAF50, #45a049);
                    color: white;
                    border: none;
                    width: 55px;
                    height: 55px;
                    border-radius: 15px;
                    font-size: 24px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                    font-weight: bold;
                  "
                  onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(76, 175, 80, 0.5)'"
                  onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.4)'"
                >
                  ✓
                </button>
                
                <!-- Indicador de votos con nuestro estilo -->
                <div id="vote-indicator-${player.name}-${category}" style="
                  display: flex;
                  flex-direction: column;
                  gap: 5px;
                  min-width: 70px;
                  align-items: center;
                  font-size: 14px;
                  color: #666;
                ">
                  <div style="font-weight: 600;">Votos</div>
                  <div id="vote-count-${player.name}-${category}">0/0</div>
                </div>
                
                <!-- Botón INVÁLIDA -->
                <button 
                  id="vote-invalid-${player.name}-${category}"
                  onclick="castVoteForWord('${player.name}', '${category}', false)"
                  style="
                    background: linear-gradient(135deg, #f44336, #d32f2f);
                    color: white;
                    border: none;
                    width: 55px;
                    height: 55px;
                    border-radius: 15px;
                    font-size: 24px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
                    font-weight: bold;
                  "
                  onmouseover="this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(244, 67, 54, 0.5)'"
                  onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(244, 67, 54, 0.4)'"
                >
                  ✗
                </button>
              </div>
            `;
            
            playersGrid.appendChild(playerVoteCard);
          });
          
          categorySection.appendChild(playersGrid);
          votingContainer.appendChild(categorySection);
        });
        
        // Inicializar estado de votación
        initializeVotingState(data);
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error procesando datos de revisión:', error);
      }
    }
    
    // Handler para estado de sala (fallback)
    function handleNativeRoomState(data) {
      try {
        console.log('🏠 [GAME.HTML] Estado de sala recibido:', data);
        
        // Si estamos en revisión pero no recibimos reviewData, mostrar info básica
        const statusDiv = document.getElementById('review-status');
        if (statusDiv) {
          statusDiv.innerHTML = `
            <span style="color: #FF9800;">⏳ Preparando revisión...</span><br>
            Sala: ${data.roomId} | Jugadores: ${data.players?.length || 0}
          `;
        }
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error procesando estado de sala:', error);
      }
    }
    
    // Finalizar revisión nativa
    function finishNativeReview() {
      try {
        console.log('🔄 [GAME.HTML] Finalizando revisión nativa...');
        
        // Remover interfaz de revisión
        const reviewContainer = document.getElementById('native-review-container');
        if (reviewContainer) {
          reviewContainer.remove();
        }
        
        // Mostrar interfaz de juego nuevamente
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
          gameContainer.style.display = 'block';
        }
        
        // Notificar al servidor que terminamos la revisión
        socketManager.emit('finishReview', { roomId: gameState.roomId });
        
        showNotification('Revisión completada', 'success');
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error finalizando revisión:', error);
      }
    }
    
    // Handler para cuando la revisión termina
    function handleNativeReviewEnded(data) {
      try {
        console.log('✅ [GAME.HTML] Revisión terminada:', data);
        finishNativeReview();
        
        if (data.nextRound) {
          showNotification(`¡Próxima ronda! Letra: ${data.nextRound.letter}`, 'info');
        }
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error manejando fin de revisión:', error);
      }
    }
    
    // SISTEMA DE VOTACIÓN - Estado y funciones
    let votingState = {
      votes: {}, // { "playerName-category": { valid: 0, invalid: 0, userVote: null } }
      totalPlayers: 0,
      currentUser: null
    };
    
    // Inicializar estado de votación
    function initializeVotingState(data) {
      try {
        console.log('🔧 [GAME.HTML] Inicializando estado de votación...');
        
        votingState.totalPlayers = data.players?.length || 0;
        votingState.currentUser = gameState.playerName;
        votingState.votes = {};
        
        // Inicializar votos para cada palabra
        data.players?.forEach(player => {
          player.words?.forEach(word => {
            const key = `${player.name}-${word.category}`;
            votingState.votes[key] = {
              valid: 0,
              invalid: 0,
              userVote: null,
              word: word.word,
              player: player.name,
              category: word.category
            };
          });
        });
        
        console.log('✅ [GAME.HTML] Estado de votación inicializado:', votingState);
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error inicializando votación:', error);
      }
    }
    
    // Función global para votar (llamada desde onclick)
    window.castVoteForWord = function(playerName, category, isValid) {
      try {
        console.log(`🗳️ [GAME.HTML] Votando: ${playerName}-${category} = ${isValid ? 'VÁLIDA' : 'INVÁLIDA'}`);
        
        const key = `${playerName}-${category}`;
        const voteData = votingState.votes[key];
        
        if (!voteData) {
          console.error('❌ [GAME.HTML] No se encontró la palabra para votar');
          return;
        }
        
        // Remover voto anterior si existe
        if (voteData.userVote !== null) {
          if (voteData.userVote) {
            voteData.valid = Math.max(0, voteData.valid - 1);
          } else {
            voteData.invalid = Math.max(0, voteData.invalid - 1);
          }
        }
        
        // Agregar nuevo voto
        voteData.userVote = isValid;
        if (isValid) {
          voteData.valid++;
        } else {
          voteData.invalid++;
        }
        
        // Actualizar UI
        updateVoteUI(playerName, category);
        
        // Enviar voto al servidor
        socketManager.emit('castVote', {
          roomId: gameState.roomId,
          playerName: playerName,
          category: category,
          isValid: isValid,
          voter: votingState.currentUser
        });
        
        // Verificar si todos han votado
        checkVotingProgress();
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error al votar:', error);
      }
    };
    
    // Actualizar UI de votación
    function updateVoteUI(playerName, category) {
      try {
        const key = `${playerName}-${category}`;
        const voteData = votingState.votes[key];
        
        if (!voteData) return;
        
        // Actualizar botones
        const validBtn = document.getElementById(`vote-valid-${playerName}-${category}`);
        const invalidBtn = document.getElementById(`vote-invalid-${playerName}-${category}`);
        const indicator = document.getElementById(`vote-count-${playerName}-${category}`);
        
        if (validBtn && invalidBtn) {
          // Resetear estilos
          validBtn.style.opacity = voteData.userVote === true ? '1' : '0.7';
          invalidBtn.style.opacity = voteData.userVote === false ? '1' : '0.7';
          
          // Agregar indicador visual de voto del usuario
          if (voteData.userVote === true) {
            validBtn.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
            validBtn.style.border = '3px solid #ffffff';
          } else {
            validBtn.style.boxShadow = '0 4px 15px rgba(76, 175, 80, 0.4)';
            validBtn.style.border = 'none';
          }
          
          if (voteData.userVote === false) {
            invalidBtn.style.boxShadow = '0 0 20px rgba(244, 67, 54, 0.8)';
            invalidBtn.style.border = '3px solid #ffffff';
          } else {
            invalidBtn.style.boxShadow = '0 4px 15px rgba(244, 67, 54, 0.4)';
            invalidBtn.style.border = 'none';
          }
        }
        
        // Actualizar contador
        if (indicator) {
          const totalVotes = voteData.valid + voteData.invalid;
          indicator.innerHTML = `
            <div style="font-weight: 600; color: ${voteData.valid > voteData.invalid ? '#4CAF50' : voteData.invalid > voteData.valid ? '#f44336' : '#666'};">
              ${totalVotes}/${votingState.totalPlayers}
            </div>
            <div style="font-size: 12px;">
              ✓${voteData.valid} ✗${voteData.invalid}
            </div>
          `;
        }
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error actualizando UI de voto:', error);
      }
    }
    
    // Verificar progreso de votación
    function checkVotingProgress() {
      try {
        const totalWords = Object.keys(votingState.votes).length;
        const votedWords = Object.values(votingState.votes).filter(v => v.userVote !== null).length;
        
        console.log(`📊 [GAME.HTML] Progreso de votación: ${votedWords}/${totalWords} palabras votadas`);
        
        // Actualizar botón de confirmación
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          if (votedWords === totalWords) {
            confirmBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
            confirmBtn.innerHTML = '✅ Confirmar Votación Completa';
            confirmBtn.disabled = false;
          } else {
            confirmBtn.style.background = 'linear-gradient(135deg, #FF9800, #F57C00)';
            confirmBtn.innerHTML = `⏳ Votar Restantes (${votedWords}/${totalWords})`;
            confirmBtn.disabled = false; // Permitir confirmación parcial
          }
        }
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error verificando progreso:', error);
      }
    }
    
    // Confirmar resultados de votación
    function confirmVotingResults() {
      try {
        console.log('✅ [GAME.HTML] Confirmando resultados de votación...');
        
        // Recopilar todos los votos
        const votingResults = {};
        Object.values(votingState.votes).forEach(vote => {
          const key = `${vote.player}-${vote.category}`;
          votingResults[key] = {
            player: vote.player,
            category: vote.category,
            word: vote.word,
            validVotes: vote.valid,
            invalidVotes: vote.invalid,
            isValid: vote.valid > vote.invalid, // Decisión por mayoría
            userVoted: vote.userVote !== null
          };
        });
        
        console.log('📊 [GAME.HTML] Resultados compilados:', votingResults);
        
        // Enviar resultados al servidor
        socketManager.emit('finishReview', {
          roomId: gameState.roomId,
          votingResults: votingResults,
          voter: votingState.currentUser
        });
        
        // Mostrar feedback visual
        const confirmBtn = document.getElementById('confirm-votes-btn');
        if (confirmBtn) {
          confirmBtn.innerHTML = '⏳ Enviando resultados...';
          confirmBtn.disabled = true;
          confirmBtn.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
        }
        
        showNotification('Votación enviada. Esperando a otros jugadores...', 'info');
        
      } catch (error) {
        console.error('❌ [GAME.HTML] Error confirmando votación:', error);
        showNotification('Error al enviar votación', 'error');
      }
    }

    function checkAllWordsCompleted() {
      const wordInputs = document.querySelectorAll('.word-input');
      const allFilledBasic = Array.from(wordInputs).every(input => 
        input.disabled || input.value.trim().length > 0
      );
      
      // Habilitar botón si al menos una palabra está completa
      const anyCompleted = Array.from(wordInputs).some(input => 
        !input.disabled && input.value.trim().length > 0
      );
      
      // Verificar si TODAS las categorías están completas para mostrar ¡BASTA!
      const allCompleted = Array.from(wordInputs).every(input => {
        if (input.disabled) return true; // Ignorar inputs deshabilitados
        const word = input.value.trim();
        const letter = gameState.currentLetter;
        
        // Debe tener contenido Y empezar con la letra correcta
        return word.length > 0 && word.charAt(0).toUpperCase() === letter;
      });
      
      if (submitWordButton) {
        submitWordButton.disabled = !anyCompleted;
      }
      
      // Mostrar botón ¡BASTA! solo si TODO está completo
      if (bastaButton) {
        if (allCompleted && gameState.isPlaying && gameState.currentLetter) {
          bastaButton.style.display = 'inline-block';
          bastaButton.classList.add('btn--pulse'); // Efecto visual
        } else {
          bastaButton.style.display = 'none';
          bastaButton.classList.remove('btn--pulse');
        }
      }
    }

    function submitWordsClassic() {
      const words = {};
      let hasValidWords = false;
      let hasInvalid = false;

      // Recopilar palabras leyendo la grilla dinámica renderizada (no depender de constantes)
      const inputs = document.querySelectorAll('.word-input');
      inputs.forEach((input) => {
        const category = input.getAttribute('data-category');
        if (!category) return;

        const word = (input.value || '').trim();
        words[category] = word;

        if (word) {
          hasValidWords = true;

          // Validar que comience con la letra correcta
          if (gameState.currentLetter && !validateWord(word, gameState.currentLetter)) {
            hasInvalid = true;
            showNotification(
              `La palabra "${word}" debe comenzar con la letra "${gameState.currentLetter}" para la categoría "${category}"`,
              'error'
            );
            try { input.focus(); } catch (_) {}
          }
        }
      });

      if (hasInvalid) {
        return; // Abortamos el envío si hay alguna entrada inválida
      }

      if (!hasValidWords) {
        showNotification('Debes ingresar al menos una palabra', 'warning');
        return;
      }
      
      // Enviar las palabras al servidor
      socketManager.submitWords(gameState.roomId, gameState.username, words);
      
      // Deshabilitar campos y botón
      gameState.disableInputs();
      
      // Mostrar mensaje de confirmación
      document.getElementById('selectedLetter').textContent = 'Palabras enviadas. Esperando a los demás jugadores...';
      uiManager.announce('Palabras enviadas correctamente');
      showNotification('¡Palabras enviadas!', 'success');
    }

    function clearWordInputs() {
      // Limpiar inputs dinámicos
      const wordInputs = document.querySelectorAll('.word-input');
      wordInputs.forEach(input => {
        input.value = '';
      });

      // Limpiar displays si existen (compatibilidad con layout anterior)
      document.querySelectorAll('.word-display').forEach((displayDiv) => {
        displayDiv.classList.remove('valid', 'invalid', 'empty');
        displayDiv.classList.add('empty');
        const text = displayDiv.querySelector('.word-text');
        if (text) text.textContent = '';
      });
    }

    function showGameResults(results) {
      // Crear modal de resultados finales
      const modal = uiManager.createModal('gameResults', 'Resultados Finales');
      
      let resultsHTML = '<h3>🏆 Clasificación Final</h3>';
      
      // Ordenar por puntuación
      const sortedResults = results.sort((a, b) => b.score - a.score);
      
      resultsHTML += '<div class="final-scores">';
      sortedResults.forEach((player, index) => {
        const position = index + 1;
        const emoji = position === 1 ? '🥇' : position === 2 ? '🥈' : position === 3 ? '🥉' : '🏅';
        
        resultsHTML += `
          <div class="final-score-item ${position === 1 ? 'winner' : ''}">
            <span class="position">${emoji} ${position}°</span>
            <span class="player-name">${player.name}</span>
            <span class="final-score">${player.score} puntos</span>
          </div>
        `;
      });
      resultsHTML += '</div>';
      
      // Botones de acción
      resultsHTML += `
        <div class="game-end-actions">
          <button type="button" class="btn btn--primary" onclick="location.reload()">
            🔄 Jugar de nuevo
          </button>
          <button type="button" class="btn btn--secondary" onclick="location.href='${ROUTES.HOME}'">
            🏠 Volver al inicio
          </button>
        </div>
      `;
      
      modal.querySelector('.modal__body').innerHTML = resultsHTML;
      uiManager.openModal('gameResults');
      
      // Agregar estilos específicos
      const style = document.createElement('style');
      style.textContent = `
        .final-scores {
          display: grid;
          gap: var(--space-3);
          margin: var(--space-6) 0;
        }
        
        .final-score-item {
          display: flex;
          align-items: center;
          gap: var(--space-3);
          padding: var(--space-4);
          background: var(--color-gray-50);
          border-radius: var(--radius-lg);
          border: 2px solid var(--color-gray-200);
        }
        
        .final-score-item.winner {
          background: linear-gradient(135deg, #ffd700, #ffed4e);
          border-color: #ffd700;
          font-weight: var(--font-weight-semibold);
        }
        
        .position {
          font-size: var(--text-lg);
          min-width: 60px;
        }
        
        .player-name {
          flex: 1;
          font-weight: var(--font-weight-medium);
        }
        
        .final-score {
          font-weight: var(--font-weight-bold);
          color: var(--color-primary);
        }
        
        .game-end-actions {
          display: flex;
          gap: var(--space-3);
          justify-content: center;
          margin-top: var(--space-6);
        }
      `;
      document.head.appendChild(style);
    }

    // Limpieza al salir de la página
    window.addEventListener('beforeunload', () => {
      gameState.clearTimer();
      socketManager.disconnect();
    });
  </script>
</body>
</html>
