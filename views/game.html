<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Jugar Tutifrutti - Completa las categor√≠as con palabras que empiecen con la letra seleccionada">
  <title>Juego - Tutifrutti</title>
  
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/base.css">
  <link rel="stylesheet" href="/public/css/components.css">
  <link rel="stylesheet" href="/public/css/game.css">
  <link rel="stylesheet" href="/public/css/game-nextgen.css">
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>
</head>
<body class="game-layout">
  <!-- Header del juego - NUEVO DISE√ëO COMPACTO -->
  <header class="game-header-compact">
    <div class="container">
      <div class="header-stats">
        <span class="app-name">üçé TUTTI FRUTTI</span>
        <span class="timer-compact">‚è±Ô∏è <span id="timerDisplay">60s</span></span>
        <span class="players-compact">üë• <span id="playersCount">0/5</span></span>
        <span class="score-compact">üíØ <span id="userScore">0</span></span>
      </div>
    </div>
  </header>
  
  <!-- Letter Display - PROMINENTE Y CENTRADA -->
  <section class="letter-section">
    <div class="container">
      <div class="current-letter-display">
        üî• <span id="letterDisplay">?</span> üî•
      </div>
      <div class="letter-label">Letra de esta ronda</div>
    </div>
  </section>

  <!-- Contenido principal -->
  <main id="main-content" class="game-main">
    <!-- Panel de estado del juego -->
    <section class="game-status">
      <div class="status-message" id="selectedLetter" aria-live="polite">
        Esperando que comience el juego...
      </div>
    </section>

    <!-- √Årea de juego -->
    <section class="game-area">
      <!-- Rejilla din√°mica de categor√≠as - GRID 4x3 RESPONSIVE -->
      <div class="categories-grid-new" id="categoriesGrid" role="group" aria-label="Categor√≠as del juego">
        <!-- Se renderiza din√°micamente con uiManager.renderCategoriesGrid -->
      </div>
    </section>

    <!-- Panel de puntuaci√≥n -->
    <section class="score-panel">
      <h2 class="score-title">
        <span aria-hidden="true">üìä</span>
        Puntuaci√≥n
      </h2>
      <div class="score-grid" role="group" aria-label="Puntuaciones actuales">
        <div class="score-item">
          <span class="score-label">Repetidas</span>
          <span class="score-value" id="score-repetidas" aria-label="Puntos por palabras repetidas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">√önicas x2</span>
          <span class="score-value" id="score-unicas" aria-label="Puntos por palabras √∫nicas">0</span>
        </div>
        <div class="score-item">
          <span class="score-label">+3 S√≠labas x3</span>
          <span class="score-value" id="score-silabas" aria-label="Puntos por palabras con m√°s de 3 s√≠labas">0</span>
        </div>
        <div class="score-item total">
          <span class="score-label">Total</span>
          <span class="score-value" id="score-total" aria-label="Puntuaci√≥n total">0</span>
        </div>
      </div>
    </section>

    <!-- Controles del juego - NUEVA BARRA FIJA -->
    <section class="game-controls-fixed">
      <div class="container">
        <div class="controls-row">
          <button id="startGameButton" 
                  class="btn btn--primary btn--lg" 
                  style="display: none;"
                  aria-describedby="start-game-help">
            <span aria-hidden="true">üéÆ</span>
            Iniciar Juego
          </button>
          <div id="start-game-help" class="sr-only">
            Solo el anfitri√≥n puede iniciar el juego
          </div>
          
          <button id="submitWordButton" 
                  class="btn btn--success btn--lg" 
                  disabled
                  aria-describedby="submit-words-help">
            <span aria-hidden="true">üöÄ</span>
            Enviar Palabras
          </button>
          <div id="submit-words-help" class="sr-only">
            Env√≠a tus palabras cuando hayas terminado o se acabe el tiempo
          </div>
          
          <button id="bastaButton" 
                  class="btn btn--accent btn--lg" 
                  style="display: none;"
                  aria-describedby="basta-help">
            <span aria-hidden="true">‚ö°</span>
            ¬°BASTA!
          </button>
          <div id="basta-help" class="sr-only">
            Termina la ronda inmediatamente cuando hayas completado todas las categor√≠as
          </div>
          
          <button id="surrenderButton" 
                  class="btn btn--ghost btn--lg" 
                  style="display: none;"
                  aria-describedby="surrender-help">
            <span aria-hidden="true">‚è≠Ô∏è</span>
            Rendirse
          </button>
          <div id="surrender-help" class="sr-only">
            Rendirse en esta ronda
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Scripts -->
  <script type="module">
    import { socketManager } from '/public/js/socket-manager.js';
    import { gameState } from '/public/js/game-state.js';
    import { uiManager } from '/public/js/ui-manager.js';
    import { storage, validateWord, showNotification } from '/utils/helpers.js';
    import { SOCKET_EVENTS, ROUTES, GAME_CONFIG } from '/utils/constants.js';

    // Referencias a elementos
    const startGameButton = document.getElementById('startGameButton');
    const submitWordButton = document.getElementById('submitWordButton');
    const bastaButton = document.getElementById('bastaButton');
    const surrenderButton = document.getElementById('surrenderButton');
    const letterDisplay = document.getElementById('letterDisplay');
    const userScoreElement = document.getElementById('userScore');

    // Exponer para acceso global
    window.gameModule = {
      submitWords: submitWordsClassic
    };

    // Inicializaci√≥n
    init();

    function init() {
      // Verificar usuario y sala
      const username = storage.getUsername();
      const urlParams = new URLSearchParams(window.location.search);
      const roomId = urlParams.get('roomId') || storage.getCurrentRoomId();

      if (!username) {
        showNotification('Debes ingresar tu nombre primero', 'error');
        window.location.href = ROUTES.HOME;
        return;
      }

      if (!roomId) {
        showNotification('No se especific√≥ una sala v√°lida', 'error');
        window.location.href = ROUTES.CREATE_ROOM;
        return;
      }

      // Configurar estado del juego
      gameState.username = username;
      gameState.roomId = roomId;

      // Actualizar UI inicial
      if (userScoreElement) {
        userScoreElement.textContent = '0';
      }

      // Inicializar componentes
      uiManager.init();
      
      // Conectar socket y configurar eventos
      socketManager.connect();
      window.socketManager = socketManager;
      setupSocketListeners();
      setupEventListeners();
      attachWordInputEvents();

      // NO unirse nuevamente - ya estamos unidos desde la sala de espera
      // En su lugar, solicitar el estado actual de la sala
      requestRoomState(roomId);

      console.log('Juego inicializado:', { username, roomId });
    }

    function requestRoomState(roomId) {
      // Verificar si venimos de la sala de espera (evitar doble uni√≥n)
      const cameFromWaitingRoom = document.referrer.includes('join-room.html') || 
                                  document.referrer.includes('create-room.html');
      
      // Siempre intentar rehidratar estado v√≠a getRoomState y reconectar internamente
      socketManager.getRoomState({ roomId });
      console.log('Solicitando estado de sala');
    }

    function setupEventListeners() {
      // Bot√≥n iniciar juego - NUEVO FLUJO: Auto-letter inmediata
      startGameButton?.addEventListener('click', () => {
        if (gameState.isHost) {
          startGameButton.disabled = true;
          startGameButton.innerHTML = '<span class="spinner"></span> Iniciando...';
          socketManager.startGame(gameState.roomId);
          showNotification('¬°Iniciando juego con letra autom√°tica!', 'info');
        } else {
          showNotification('Solo el anfitri√≥n puede iniciar el juego', 'warning');
        }
      });

      // Bot√≥n enviar palabras
      submitWordButton?.addEventListener('click', submitWordsClassic);
      
      // Bot√≥n ¬°BASTA! - Termina la ronda inmediatamente
      bastaButton?.addEventListener('click', () => {
        console.log('üî• ¬°BASTA! presionado - terminando ronda inmediatamente');
        
        // Enviar palabras y forzar fin de ronda
        submitWordsClassic();
        
        // Notificar al servidor que se termin√≥ la ronda
        socketManager.emit('forceEndRound', { 
          roomId: gameState.roomId,
          playerName: gameState.username 
        });
        
        showNotification('¬°Has terminado la ronda!', 'success');
        
        // Ocultar bot√≥n despu√©s de usar
        bastaButton.style.display = 'none';
      });
      
      // Bot√≥n rendirse
      surrenderButton?.addEventListener('click', () => {
        if (confirm('¬øEst√°s seguro de que quieres rendirte en esta ronda?')) {
          submitWordsClassic(); // Env√≠a palabras actuales
          showNotification('Te has rendido en esta ronda', 'info');
        }
      });
    }

    function attachWordInputEvents() {
      const wordInputs = document.querySelectorAll('.word-input');
      
      wordInputs.forEach((input, index) => {
        // Navegaci√≥n con Enter
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            moveToNextCategory(index);
          }
          
          // Enviar con Ctrl+Enter
          if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            submitWordsClassic();
          }
        });

        // Validaci√≥n en tiempo real con restricci√≥n de letra
        input.addEventListener('input', function() {
          const category = this.getAttribute('data-category');
          let word = this.value.trim();
          
          // NUEVA VALIDACI√ìN: Bloquear primera letra incorrecta
          if (word.length > 0 && gameState.currentLetter) {
            const firstChar = normalizeFirstLetter(word.charAt(0));
            const targetLetter = gameState.currentLetter.toUpperCase();
            
            if (firstChar !== targetLetter) {
              // Bloquear entrada - remover √∫ltimo car√°cter
              this.value = word.slice(0, -1);
              word = this.value.trim();
              
              // Feedback visual de error
              this.classList.add('blocked');
              setTimeout(() => this.classList.remove('blocked'), 200);
              
              // Mostrar mensaje de error temporal
              showTemporaryError(this, `Debe empezar con "${targetLetter}"`);
              return;
            }
          }
          
          // No validar autom√°ticamente - la validaci√≥n se hace en revisi√≥n social
          const hasContent = word && word.length > 0;
          
          // Actualizar visualizaci√≥n sin validaci√≥n autom√°tica
          updateCategoryCardState(this, category, word, hasContent);
          
          // Verificar si todas las palabras est√°n completas
          checkAllWordsCompleted();
        });

        // Gesti√≥n del foco
        input.addEventListener('focus', function() {
          uiManager.setActiveInput(this);
        });

        input.addEventListener('blur', function() {
          uiManager.removeActiveInput(this);
        });
      });
    }

    function setupSocketListeners() {
      // Conexi√≥n y errores
      socketManager.on(SOCKET_EVENTS.JOINED_ROOM, handleJoinedRoom);
      socketManager.on(SOCKET_EVENTS.PLAYER_JOINED, handlePlayerJoined);
      socketManager.on(SOCKET_EVENTS.PLAYER_LEFT, handlePlayerLeft);
      
      // Estado de la sala
      socketManager.on(SOCKET_EVENTS.ROOM_STATE, handleRoomState);
      
      // Juego - NUEVO FLUJO: Solo ROUND_START
      socketManager.on(SOCKET_EVENTS.ROUND_START, handleRoundStart);
      socketManager.on(SOCKET_EVENTS.START_REVIEW, handleStartReview);
      socketManager.on(SOCKET_EVENTS.TIMER_UPDATE, handleTimerUpdate);
      socketManager.on(SOCKET_EVENTS.ROUND_ENDED, handleRoundEnded);
      socketManager.on(SOCKET_EVENTS.GAME_ENDED, handleGameEnded);

      // Eventos futuros (validaci√≥n social)
      // Ya configurado arriba
      socketManager.on(SOCKET_EVENTS.VOTE_UPDATE, handleVoteUpdate);
      socketManager.on(SOCKET_EVENTS.REVIEW_ENDED, handleReviewEnded);

      // Eventos de host
      socketManager.on(SOCKET_EVENTS.YOU_ARE_CREATOR, () => {
        gameState.setHost(true);
        const startButton = document.getElementById('startGameButton');
        if (startButton) startButton.style.display = 'block';
      });
    }

    function handleRoomState(data) {
      console.log('Estado de la sala recibido:', data);
      
      if (!data || !data.players) {
        console.error('Estado de sala inv√°lido:', data);
        showNotification('Error al cargar el estado de la sala', 'error');
        return;
      }
      
      // Actualizar estado del juego
      gameState.updatePlayers(data.players);
      
      // Verificar si el jugador actual es el creador
      const currentPlayer = data.players.find(p => p.name === gameState.username);
      const isCreator = currentPlayer ? currentPlayer.isCreator : false;
      gameState.setHost(isCreator);
      
      console.log(`Jugador actual: ${gameState.username}, Es creador: ${isCreator}`);
      
      // NUEVO FLUJO: Sin ruleta, directo a juego si est√° en curso
      if (data.isPlaying) {
        gameState.startGame();
        if (data.currentLetter) {
          // Juego en curso con letra: renderizar categor√≠as y mostrar letra
          displayCurrentLetter(data.currentLetter);
          uiManager.renderCategoriesGrid(data.categories || GAME_CONFIG.CATEGORIES);
          attachWordInputEvents();
          gameState.setCurrentLetter(data.currentLetter);
          document.getElementById('selectedLetter').textContent = `¬°Escribiendo con la letra ${data.currentLetter}!`;
        } else {
          // Juego en curso sin letra: estado transitorio, esperar ROUND_START
          document.getElementById('selectedLetter').textContent = 'Generando letra autom√°tica...';
        }
        if (startGameButton) startGameButton.style.display = 'none';
      } else if (isCreator) {
        // Mostrar bot√≥n de iniciar juego si es el creador y el juego no ha empezado
        if (startGameButton) {
          startGameButton.style.display = 'block';
        }
        document.getElementById('selectedLetter').textContent = '¬°Haz clic en "Iniciar Juego" para comenzar!';
        uiManager.announce('Eres el anfitri√≥n. Puedes iniciar el juego cuando est√©s listo.');
      } else {
        document.getElementById('selectedLetter').textContent = 'Esperando que el anfitri√≥n inicie el juego...';
      }
      
      uiManager.announce(`Estado del juego cargado. ${data.players.length} jugadores en la sala.`);
      showNotification('¬°Listo para jugar!', 'success');
    }

    function handleJoinedRoom(data) {
      console.log('Unido a la sala:', data);
      
      gameState.updatePlayers(data.players || []);
      const isCreator = data.isCreator || false;
      gameState.setHost(isCreator);
      
      console.log(`Unido a sala - Es creador: ${isCreator}`);
      
      // Si es el creador, mostrar controles apropiados
      if (isCreator) {
        const startButton = document.getElementById('startGameButton');
        if (startButton) {
          startButton.style.display = 'block';
        }
        uiManager.announce('Eres el anfitri√≥n de esta sala.');
      }
      
      uiManager.announce(`Te has unido a la sala. Hay ${data.players?.length || 0} jugadores.`);
    }

    function handlePlayerJoined(data) {
      console.log('Jugador se uni√≥:', data);
      if (data && data.players) {
        gameState.updatePlayers(data.players);
      }
      const playerName = data?.player?.name;
      if (playerName && playerName !== gameState.username) {
        uiManager.announce(`${playerName} se uni√≥ al juego`);
        showNotification(`${playerName} se uni√≥ al juego`, 'info');
      }
    }

    function handlePlayerLeft(data) {
      console.log('Jugador se fue:', data);
      
      if (data.players) {
        gameState.updatePlayers(data.players);
        
        if (data.playerName && data.playerName !== gameState.username) {
          uiManager.announce(`${data.playerName} dej√≥ el juego`);
          showNotification(`${data.playerName} dej√≥ el juego`, 'info');
        }
      }
    }

    // NUEVA FUNCI√ìN: Mostrar letra en header compacto
    function displayCurrentLetter(letter) {
      if (letterDisplay) {
        letterDisplay.textContent = letter;
      }
      // Tambi√©n actualizar en el panel de estado
      const statusMessage = document.getElementById('selectedLetter');
      if (statusMessage) {
        statusMessage.textContent = `¬°Escribiendo con la letra ${letter}!`;
      }
      uiManager.announce(`Letra seleccionada: ${letter}. ¬°A escribir!`);
    }

    // FUNCI√ìN: Normalizar primera letra (tildes + √ë)
    function normalizeFirstLetter(char) {
      const normalized = char.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      return normalized.toUpperCase();
    }

    // FUNCI√ìN: Mostrar error temporal en input
    function showTemporaryError(input, message) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Crear elemento de error temporal
      const errorEl = document.createElement('div');
      errorEl.className = 'temp-error';
      errorEl.textContent = message;
      errorEl.style.cssText = `
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--color-error);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        animation: errorPulse 2s ease-out forwards;
      `;
      
      card.style.position = 'relative';
      card.appendChild(errorEl);
      
      setTimeout(() => {
        if (errorEl.parentNode) {
          errorEl.parentNode.removeChild(errorEl);
        }
      }, 2000);
    }

    // FUNCI√ìN: Actualizar estado visual de categoria card (SIN validaci√≥n autom√°tica)
    function updateCategoryCardState(input, category, word, hasContent) {
      const card = input.closest('.category-card');
      if (!card) return;
      
      // Limpiar clases previas
      card.classList.remove('completed', 'invalid', 'empty', 'filled');
      input.classList.remove('valid', 'invalid', 'filled');
      
      if (hasContent) {
        // Solo marcar como "filled" sin validar
        card.classList.add('filled');
        input.classList.add('filled');
      } else {
        card.classList.add('empty');
      }
      
      // Actualizar feedback visual sin validaci√≥n
      updateCategoryFeedback(card, word, hasContent);
    }

    // FUNCI√ìN: Feedback visual en categoria card (SIN validaci√≥n autom√°tica)
    function updateCategoryFeedback(card, word, hasContent) {
      let feedbackEl = card.querySelector('.category-card__feedback');
      
      if (hasContent) {
        if (!feedbackEl) {
          feedbackEl = document.createElement('div');
          feedbackEl.className = 'category-card__feedback';
          card.appendChild(feedbackEl);
        }
        
        // Solo mostrar que tiene contenido, sin validar
        feedbackEl.className = 'category-card__feedback filled';
        feedbackEl.textContent = 'üìù';
        feedbackEl.setAttribute('aria-label', 'Palabra ingresada');
      } else if (feedbackEl) {
        feedbackEl.remove();
      }
    }

    // NUEVO FLUJO: Round start con auto-letter inmediata
    function handleRoundStart(data) {
      try {
        console.log('[Game] handleRoundStart - NUEVO FLUJO:', data);
        
        const categories = data?.categories || GAME_CONFIG.CATEGORIES;
        
        // Ocultar bot√≥n de iniciar juego
        if (startGameButton) startGameButton.style.display = 'none';
        
        // Mostrar letra en header compacto
        displayCurrentLetter(data.letter);
        
        // Render de categor√≠as din√°micas en grid 4x3
        uiManager.renderCategoriesGrid(categories);
        attachWordInputEvents();
        
        // Configurar estado del juego
        gameState.setCurrentLetter(data.letter);
        gameState.enableInputs();
        gameState.startGame();

        // Mostrar bot√≥n de rendirse durante el juego
        if (surrenderButton) {
          surrenderButton.style.display = 'inline-block';
        }

        // Enfocar primer input disponible para UX
        setTimeout(() => {
          const first = document.querySelector('.word-input:not([disabled])');
          if (first) { 
            try { first.focus(); } catch(_) {} 
          }
        }, 100);

        showNotification(`¬°Ronda ${data.round} iniciada con letra ${data.letter}!`, 'success');
        uiManager.announce(`Ronda ${data.round} iniciada con letra ${data.letter}. ¬°Tiempo para escribir!`);
      } catch (e) {
        console.error('Error en handleRoundStart:', e);
        showNotification('Error al iniciar la ronda', 'error');
      }
    }

    function handleStartReview(data) {
      try {
        console.log('üîÑ [GAME.HTML] Iniciando revisi√≥n social:', data);
        console.log('üîÑ [GAME.HTML] Estado actual del juego:', {
          roomId: gameState.roomId,
          isPlaying: gameState.isPlaying,
          timeRemaining: gameState.timeRemaining
        });
        
        // Bloquear entradas y bot√≥n de enviar
        gameState.disableInputs();
        if (submitWordButton) submitWordButton.disabled = true;
        
        // Mostrar notificaci√≥n de transici√≥n
        showNotification(data.message || '¬°Hora de revisar las palabras!', 'info');
        
        // SOLUCI√ìN DEFINITIVA: Cargar revisi√≥n en la misma p√°gina
        try {
          console.log('üîÑ [GAME.HTML] Cargando revisi√≥n en la misma p√°gina...');
          
          // Guardar estado cr√≠tico
          localStorage.setItem('reviewTransition', 'true');
          localStorage.setItem('reviewData', JSON.stringify(data));
          
          // Ocultar interfaz de juego
          const gameContainer = document.querySelector('.game-container');
          if (gameContainer) {
            gameContainer.style.display = 'none';
          }
          
          // Cargar revisi√≥n din√°micamente
          loadReviewInterface(data);
          
        } catch (error) {
          console.error('‚ùå [GAME.HTML] Error cargando revisi√≥n:', error);
          // Fallback: mostrar mensaje de error
          showNotification('Error al cargar revisi√≥n', 'error');
        }
        
      } catch (e) {
        console.error('Error en handleStartReview:', e);
        showNotification('Error al iniciar la revisi√≥n', 'error');
      }
    }

    function handleVoteUpdate(data) {
      try {
        uiManager.updateVoteCounts(data);
      } catch (e) {
        console.error('Error en handleVoteUpdate:', e);
      }
    }

    function handleReviewEnded(data) {
      try {
        // Cerrar modal de revisi√≥n; los resultados llegar√°n por ROUND_ENDED
        uiManager.closeReviewModal();
      } catch (e) {
        console.error('Error en handleReviewEnded:', e);
      }
    }

    function handleTimerUpdate(data) {
      gameState.timeRemaining = data.timeRemaining;
      gameState.updateTimerDisplay();
      
      // Advertencia cuando queden pocos segundos
      if (data.timeRemaining <= 10 && data.timeRemaining > 0) {
        if (data.timeRemaining <= 5) {
          uiManager.announce(`¬°${data.timeRemaining} segundos!`);
        }
      }
      if (data.timeRemaining <= 0) {
        // Evitar acciones locales; el servidor cerrar√° la ronda
        gameState.clearTimer();
      }
    }

    function handleRoundEnded(data) {
      console.log('[Game] handleRoundEnded ->', data);
      
      gameState.clearTimer();
      gameState.disableInputs();
      gameState.updatePlayerScore(data.scores);
      
      // Mostrar resultados
      uiManager.showRoundResults(data);
      
      // Limpiar campos para la siguiente ronda
      clearWordInputs();
      
      uiManager.announce('La ronda ha terminado. Revisa los resultados.');
      
      // Preparar para la siguiente ronda: esperar ROUND_START del servidor
      const selectedLetterEl = document.getElementById('selectedLetter');
      if (selectedLetterEl) {
        selectedLetterEl.textContent = 'Esperando siguiente ronda...';
      }
    }

    function handleGameEnded(data) {
      console.log('Juego terminado:', data);
      
      gameState.clearTimer();
      gameState.gameStarted = false;
      
      // Mostrar resultados finales
      showGameResults(data.results);
      
      uiManager.announce('El juego ha terminado. Revisa los resultados finales.');
    }

    function moveToNextCategory(currentIndex) {
      const wordInputs = document.querySelectorAll('.word-input');
      const nextIndex = (currentIndex + 1) % wordInputs.length;
      
      if (nextIndex < wordInputs.length && !wordInputs[nextIndex].disabled) {
        wordInputs[nextIndex].focus();
      }
    }
    
    // SOLUCI√ìN DEFINITIVA: Cargar interfaz de revisi√≥n en la misma p√°gina
    function loadReviewInterface(data) {
      try {
        console.log('üîÑ [GAME.HTML] Implementando interfaz de revisi√≥n...');
        
        // Crear contenedor de revisi√≥n
        const reviewContainer = document.createElement('div');
        reviewContainer.id = 'review-container';
        reviewContainer.innerHTML = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            font-size: 24px;
            text-align: center;
          ">
            <div>
              <div style="font-size: 48px; margin-bottom: 20px;">üîç</div>
              <div>Revisi√≥n de palabras</div>
              <div style="font-size: 16px; margin-top: 10px;">Ronda ${data.round} - Letra ${data.letter}</div>
              <div style="font-size: 14px; margin-top: 20px; opacity: 0.8;">
                Manteniendo conexi√≥n activa...<br>
                Redirigiendo a p√°gina de revisi√≥n en 3 segundos
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(reviewContainer);
        
        // Redirigir despu√©s de 3 segundos para dar tiempo a que se establezca la conexi√≥n
        setTimeout(() => {
          console.log('üîÑ [GAME.HTML] Redirigiendo a review.html...');
          const reviewUrl = data.reviewUrl || `/views/review.html?roomId=${gameState.roomId}`;
          window.location.href = reviewUrl;
        }, 3000);
        
      } catch (error) {
        console.error('‚ùå [GAME.HTML] Error en loadReviewInterface:', error);
        // Fallback: redirecci√≥n directa
        const reviewUrl = data.reviewUrl || `/views/review.html?roomId=${gameState.roomId}`;
        window.location.href = reviewUrl;
      }
    }

    function checkAllWordsCompleted() {
      const wordInputs = document.querySelectorAll('.word-input');
      const allFilledBasic = Array.from(wordInputs).every(input => 
        input.disabled || input.value.trim().length > 0
      );
      
      // Habilitar bot√≥n si al menos una palabra est√° completa
      const anyCompleted = Array.from(wordInputs).some(input => 
        !input.disabled && input.value.trim().length > 0
      );
      
      // Verificar si TODAS las categor√≠as est√°n completas para mostrar ¬°BASTA!
      const allCompleted = Array.from(wordInputs).every(input => {
        if (input.disabled) return true; // Ignorar inputs deshabilitados
        const word = input.value.trim();
        const letter = gameState.currentLetter;
        
        // Debe tener contenido Y empezar con la letra correcta
        return word.length > 0 && word.charAt(0).toUpperCase() === letter;
      });
      
      if (submitWordButton) {
        submitWordButton.disabled = !anyCompleted;
      }
      
      // Mostrar bot√≥n ¬°BASTA! solo si TODO est√° completo
      if (bastaButton) {
        if (allCompleted && gameState.isPlaying && gameState.currentLetter) {
          bastaButton.style.display = 'inline-block';
          bastaButton.classList.add('btn--pulse'); // Efecto visual
        } else {
          bastaButton.style.display = 'none';
          bastaButton.classList.remove('btn--pulse');
        }
      }
    }

    function submitWordsClassic() {
      const words = {};
      let hasValidWords = false;
      let hasInvalid = false;

      // Recopilar palabras leyendo la grilla din√°mica renderizada (no depender de constantes)
      const inputs = document.querySelectorAll('.word-input');
      inputs.forEach((input) => {
        const category = input.getAttribute('data-category');
        if (!category) return;

        const word = (input.value || '').trim();
        words[category] = word;

        if (word) {
          hasValidWords = true;

          // Validar que comience con la letra correcta
          if (gameState.currentLetter && !validateWord(word, gameState.currentLetter)) {
            hasInvalid = true;
            showNotification(
              `La palabra "${word}" debe comenzar con la letra "${gameState.currentLetter}" para la categor√≠a "${category}"`,
              'error'
            );
            try { input.focus(); } catch (_) {}
          }
        }
      });

      if (hasInvalid) {
        return; // Abortamos el env√≠o si hay alguna entrada inv√°lida
      }

      if (!hasValidWords) {
        showNotification('Debes ingresar al menos una palabra', 'warning');
        return;
      }
      
      // Enviar las palabras al servidor
      socketManager.submitWords(gameState.roomId, gameState.username, words);
      
      // Deshabilitar campos y bot√≥n
      gameState.disableInputs();
      
      // Mostrar mensaje de confirmaci√≥n
      document.getElementById('selectedLetter').textContent = 'Palabras enviadas. Esperando a los dem√°s jugadores...';
      uiManager.announce('Palabras enviadas correctamente');
      showNotification('¬°Palabras enviadas!', 'success');
    }

    function clearWordInputs() {
      // Limpiar inputs din√°micos
      const wordInputs = document.querySelectorAll('.word-input');
      wordInputs.forEach(input => {
        input.value = '';
      });

      // Limpiar displays si existen (compatibilidad con layout anterior)
      document.querySelectorAll('.word-display').forEach((displayDiv) => {
        displayDiv.classList.remove('valid', 'invalid', 'empty');
        displayDiv.classList.add('empty');
        const text = displayDiv.querySelector('.word-text');
        if (text) text.textContent = '';
      });
    }

    function showGameResults(results) {
      // Crear modal de resultados finales
      const modal = uiManager.createModal('gameResults', 'Resultados Finales');
      
      let resultsHTML = '<h3>üèÜ Clasificaci√≥n Final</h3>';
      
      // Ordenar por puntuaci√≥n
      const sortedResults = results.sort((a, b) => b.score - a.score);
      
      resultsHTML += '<div class="final-scores">';
      sortedResults.forEach((player, index) => {
        const position = index + 1;
        const emoji = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : 'üèÖ';
        
        resultsHTML += `
          <div class="final-score-item ${position === 1 ? 'winner' : ''}">
            <span class="position">${emoji} ${position}¬∞</span>
            <span class="player-name">${player.name}</span>
            <span class="final-score">${player.score} puntos</span>
          </div>
        `;
      });
      resultsHTML += '</div>';
      
      // Botones de acci√≥n
      resultsHTML += `
        <div class="game-end-actions">
          <button type="button" class="btn btn--primary" onclick="location.reload()">
            üîÑ Jugar de nuevo
          </button>
          <button type="button" class="btn btn--secondary" onclick="location.href='${ROUTES.HOME}'">
            üè† Volver al inicio
          </button>
        </div>
      `;
      
      modal.querySelector('.modal__body').innerHTML = resultsHTML;
      uiManager.openModal('gameResults');
      
      // Agregar estilos espec√≠ficos
      const style = document.createElement('style');
      style.textContent = `
        .final-scores {
          display: grid;
          gap: var(--space-3);
          margin: var(--space-6) 0;
        }
        
        .final-score-item {
          display: flex;
          align-items: center;
          gap: var(--space-3);
          padding: var(--space-4);
          background: var(--color-gray-50);
          border-radius: var(--radius-lg);
          border: 2px solid var(--color-gray-200);
        }
        
        .final-score-item.winner {
          background: linear-gradient(135deg, #ffd700, #ffed4e);
          border-color: #ffd700;
          font-weight: var(--font-weight-semibold);
        }
        
        .position {
          font-size: var(--text-lg);
          min-width: 60px;
        }
        
        .player-name {
          flex: 1;
          font-weight: var(--font-weight-medium);
        }
        
        .final-score {
          font-weight: var(--font-weight-bold);
          color: var(--color-primary);
        }
        
        .game-end-actions {
          display: flex;
          gap: var(--space-3);
          justify-content: center;
          margin-top: var(--space-6);
        }
      `;
      document.head.appendChild(style);
    }

    // Limpieza al salir de la p√°gina
    window.addEventListener('beforeunload', () => {
      gameState.clearTimer();
      socketManager.disconnect();
    });
  </script>
</body>
</html>
